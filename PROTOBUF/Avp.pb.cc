// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Avp.proto
// Protobuf C++ Version: 5.28.0

#include "Avp.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace keti {

inline constexpr Version::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : major_{0u},
        minor_{0u},
        patch_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Version::Version(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;

inline constexpr Ids::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : session_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        message_id_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Ids::Ids(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct IdsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IdsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~IdsDefaultTypeInternal() {}
  union {
    Ids _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IdsDefaultTypeInternal _Ids_default_instance_;

inline constexpr AvpVehicleSteeringSensor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : sas_angle_{0},
        sas_speed_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleSteeringSensor::AvpVehicleSteeringSensor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleSteeringSensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleSteeringSensorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleSteeringSensorDefaultTypeInternal() {}
  union {
    AvpVehicleSteeringSensor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleSteeringSensorDefaultTypeInternal _AvpVehicleSteeringSensor_default_instance_;

inline constexpr AvpVehicleStabilitySensor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : esp_lat_accel_{0},
        esp_long_accel_{0},
        esp_yaw_rate_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleStabilitySensor::AvpVehicleStabilitySensor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleStabilitySensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleStabilitySensorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleStabilitySensorDefaultTypeInternal() {}
  union {
    AvpVehicleStabilitySensor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleStabilitySensorDefaultTypeInternal _AvpVehicleStabilitySensor_default_instance_;

inline constexpr AvpVehicleParkingSensor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : fr_alarm_{0u},
        fcs_alarm_{0u},
        fls_alarm_{0u},
        frs_alarm_{0u},
        fi_ind_{0u},
        fol_ind_{0u},
        for_ind_{0u},
        rr_alarm_{0u},
        rcs_alarm_{0u},
        rls_alarm_{0u},
        rrs_alarm_{0u},
        ri_ind_{0u},
        rol_ind_{0u},
        ror_ind_{0u},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleParkingSensor::AvpVehicleParkingSensor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleParkingSensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleParkingSensorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleParkingSensorDefaultTypeInternal() {}
  union {
    AvpVehicleParkingSensor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleParkingSensorDefaultTypeInternal _AvpVehicleParkingSensor_default_instance_;

inline constexpr AvpVehicleDoorSensor::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : front_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleDoorSensor::AvpVehicleDoorSensor(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleDoorSensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleDoorSensorDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleDoorSensorDefaultTypeInternal() {}
  union {
    AvpVehicleDoorSensor _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleDoorSensorDefaultTypeInternal _AvpVehicleDoorSensor_default_instance_;

inline constexpr AvpParkingSpaces::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : parked_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpParkingSpaces::AvpParkingSpaces(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpParkingSpacesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpParkingSpacesDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpParkingSpacesDefaultTypeInternal() {}
  union {
    AvpParkingSpaces _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpParkingSpacesDefaultTypeInternal _AvpParkingSpaces_default_instance_;

inline constexpr AvpGridPos::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : x_{0},
        y_{0},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpGridPos::AvpGridPos(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpGridPosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpGridPosDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpGridPosDefaultTypeInternal() {}
  union {
    AvpGridPos _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpGridPosDefaultTypeInternal _AvpGridPos_default_instance_;

inline constexpr AvpControlMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : type_{static_cast< ::keti::AvpControlMessage_Type >(0)},
        code_{static_cast< ::keti::AvpControlMessage_Code >(0)},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpControlMessage::AvpControlMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpControlMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpControlMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpControlMessageDefaultTypeInternal() {}
  union {
    AvpControlMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpControlMessageDefaultTypeInternal _AvpControlMessage_default_instance_;

inline constexpr Entity::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        primary_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        secondary_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        software_version_{nullptr},
        hardware_version_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Entity::Entity(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EntityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityDefaultTypeInternal() {}
  union {
    Entity _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityDefaultTypeInternal _Entity_default_instance_;

inline constexpr AvpVehiclePos::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        pos1_{nullptr},
        pos2_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehiclePos::AvpVehiclePos(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehiclePosDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehiclePosDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehiclePosDefaultTypeInternal() {}
  union {
    AvpVehiclePos _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehiclePosDefaultTypeInternal _AvpVehiclePos_default_instance_;

inline constexpr AvpVehicleAbnormalData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        time_{nullptr},
        type_{static_cast< ::keti::AvpVehicleAbnormalData_AbnormalType >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleAbnormalData::AvpVehicleAbnormalData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleAbnormalDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleAbnormalDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleAbnormalDataDefaultTypeInternal() {}
  union {
    AvpVehicleAbnormalData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleAbnormalDataDefaultTypeInternal _AvpVehicleAbnormalData_default_instance_;

inline constexpr AvpCANSensorData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        time_{nullptr},
        parking_{nullptr},
        steering_{nullptr},
        stability_{nullptr},
        door_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR AvpCANSensorData::AvpCANSensorData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpCANSensorDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpCANSensorDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpCANSensorDataDefaultTypeInternal() {}
  union {
    AvpCANSensorData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpCANSensorDataDefaultTypeInternal _AvpCANSensorData_default_instance_;

inline constexpr Envelope::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        version_{nullptr},
        submitter_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Envelope::Envelope(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct EnvelopeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EnvelopeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~EnvelopeDefaultTypeInternal() {}
  union {
    Envelope _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EnvelopeDefaultTypeInternal _Envelope_default_instance_;

inline constexpr AvpVehicleAbnormalDataStream::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : data_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicleAbnormalDataStream::AvpVehicleAbnormalDataStream(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleAbnormalDataStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleAbnormalDataStreamDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleAbnormalDataStreamDefaultTypeInternal() {}
  union {
    AvpVehicleAbnormalDataStream _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleAbnormalDataStreamDefaultTypeInternal _AvpVehicleAbnormalDataStream_default_instance_;

inline constexpr AvpVehicle::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        pos_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR AvpVehicle::AvpVehicle(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpVehicleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpVehicleDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpVehicleDefaultTypeInternal() {}
  union {
    AvpVehicle _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpVehicleDefaultTypeInternal _AvpVehicle_default_instance_;

inline constexpr AvpDataMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : data_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR AvpDataMessage::AvpDataMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpDataMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpDataMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpDataMessageDefaultTypeInternal() {}
  union {
    AvpDataMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpDataMessageDefaultTypeInternal _AvpDataMessage_default_instance_;

inline constexpr AvpMessage::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        envelope_{nullptr},
        id_{nullptr},
        message_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR AvpMessage::AvpMessage(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpMessageDefaultTypeInternal() {}
  union {
    AvpMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpMessageDefaultTypeInternal _AvpMessage_default_instance_;

inline constexpr AvpCCTVMonitoringData::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        avp_cars_{},
        cars_{},
        persons_{},
        time_{nullptr},
        spaces_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR AvpCCTVMonitoringData::AvpCCTVMonitoringData(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AvpCCTVMonitoringDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AvpCCTVMonitoringDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AvpCCTVMonitoringDataDefaultTypeInternal() {}
  union {
    AvpCCTVMonitoringData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AvpCCTVMonitoringDataDefaultTypeInternal _AvpCCTVMonitoringData_default_instance_;
}  // namespace keti
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_Avp_2eproto[3];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_Avp_2eproto = nullptr;
const ::uint32_t
    TableStruct_Avp_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::Version, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::Version, _impl_.major_),
        PROTOBUF_FIELD_OFFSET(::keti::Version, _impl_.minor_),
        PROTOBUF_FIELD_OFFSET(::keti::Version, _impl_.patch_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_.primary_id_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_.secondary_id_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_.software_version_),
        PROTOBUF_FIELD_OFFSET(::keti::Entity, _impl_.hardware_version_),
        ~0u,
        ~0u,
        ~0u,
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::keti::Envelope, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::Envelope, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::Envelope, _impl_.version_),
        PROTOBUF_FIELD_OFFSET(::keti::Envelope, _impl_.submitter_),
        0,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::Ids, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::Ids, _impl_.session_id_),
        PROTOBUF_FIELD_OFFSET(::keti::Ids, _impl_.message_id_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalData, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalData, _impl_.type_),
        0,
        ~0u,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalDataStream, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleAbnormalDataStream, _impl_.data_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpGridPos, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpGridPos, _impl_.x_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpGridPos, _impl_.y_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehiclePos, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehiclePos, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehiclePos, _impl_.pos1_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehiclePos, _impl_.pos2_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicle, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicle, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicle, _impl_.pos_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicle, _impl_.id_),
        0,
        ~0u,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpParkingSpaces, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpParkingSpaces, _impl_.parked_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_.avp_cars_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_.cars_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_.persons_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCCTVMonitoringData, _impl_.spaces_),
        0,
        ~0u,
        ~0u,
        ~0u,
        1,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.fr_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.fcs_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.fls_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.frs_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.fi_ind_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.fol_ind_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.for_ind_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.rr_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.rcs_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.rls_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.rrs_alarm_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.ri_ind_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.rol_ind_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleParkingSensor, _impl_.ror_ind_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleSteeringSensor, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleSteeringSensor, _impl_.sas_angle_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleSteeringSensor, _impl_.sas_speed_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleStabilitySensor, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleStabilitySensor, _impl_.esp_lat_accel_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleStabilitySensor, _impl_.esp_long_accel_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleStabilitySensor, _impl_.esp_yaw_rate_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleDoorSensor, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpVehicleDoorSensor, _impl_.front_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_.time_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_.parking_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_.steering_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_.stability_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpCANSensorData, _impl_.door_),
        0,
        1,
        2,
        3,
        4,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpControlMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpControlMessage, _impl_.type_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpControlMessage, _impl_.code_),
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::keti::AvpDataMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpDataMessage, _impl_.data_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_.envelope_),
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_.id_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_.message_),
        0,
        1,
        ~0u,
        ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, -1, sizeof(::keti::Version)},
        {11, 24, -1, sizeof(::keti::Entity)},
        {29, 39, -1, sizeof(::keti::Envelope)},
        {41, -1, -1, sizeof(::keti::Ids)},
        {51, 61, -1, sizeof(::keti::AvpVehicleAbnormalData)},
        {63, -1, -1, sizeof(::keti::AvpVehicleAbnormalDataStream)},
        {72, -1, -1, sizeof(::keti::AvpGridPos)},
        {82, 92, -1, sizeof(::keti::AvpVehiclePos)},
        {94, 104, -1, sizeof(::keti::AvpVehicle)},
        {106, -1, -1, sizeof(::keti::AvpParkingSpaces)},
        {115, 128, -1, sizeof(::keti::AvpCCTVMonitoringData)},
        {133, -1, -1, sizeof(::keti::AvpVehicleParkingSensor)},
        {155, -1, -1, sizeof(::keti::AvpVehicleSteeringSensor)},
        {165, -1, -1, sizeof(::keti::AvpVehicleStabilitySensor)},
        {176, -1, -1, sizeof(::keti::AvpVehicleDoorSensor)},
        {185, 198, -1, sizeof(::keti::AvpCANSensorData)},
        {203, -1, -1, sizeof(::keti::AvpControlMessage)},
        {213, -1, -1, sizeof(::keti::AvpDataMessage)},
        {222, 235, -1, sizeof(::keti::AvpMessage)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::keti::_Version_default_instance_._instance,
    &::keti::_Entity_default_instance_._instance,
    &::keti::_Envelope_default_instance_._instance,
    &::keti::_Ids_default_instance_._instance,
    &::keti::_AvpVehicleAbnormalData_default_instance_._instance,
    &::keti::_AvpVehicleAbnormalDataStream_default_instance_._instance,
    &::keti::_AvpGridPos_default_instance_._instance,
    &::keti::_AvpVehiclePos_default_instance_._instance,
    &::keti::_AvpVehicle_default_instance_._instance,
    &::keti::_AvpParkingSpaces_default_instance_._instance,
    &::keti::_AvpCCTVMonitoringData_default_instance_._instance,
    &::keti::_AvpVehicleParkingSensor_default_instance_._instance,
    &::keti::_AvpVehicleSteeringSensor_default_instance_._instance,
    &::keti::_AvpVehicleStabilitySensor_default_instance_._instance,
    &::keti::_AvpVehicleDoorSensor_default_instance_._instance,
    &::keti::_AvpCANSensorData_default_instance_._instance,
    &::keti::_AvpControlMessage_default_instance_._instance,
    &::keti::_AvpDataMessage_default_instance_._instance,
    &::keti::_AvpMessage_default_instance_._instance,
};
const char descriptor_table_protodef_Avp_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\tAvp.proto\022\004keti\032\037google/protobuf/times"
    "tamp.proto\"6\n\007Version\022\r\n\005major\030\001 \001(\r\022\r\n\005"
    "minor\030\002 \001(\r\022\r\n\005patch\030\003 \001(\r\"\222\001\n\006Entity\022\022\n"
    "\nprimary_id\030\001 \001(\t\022\024\n\014secondary_id\030\002 \001(\t\022"
    "\014\n\004type\030\003 \001(\t\022\'\n\020software_version\030\004 \001(\0132"
    "\r.keti.Version\022\'\n\020hardware_version\030\005 \001(\013"
    "2\r.keti.Version\"K\n\010Envelope\022\036\n\007version\030\001"
    " \001(\0132\r.keti.Version\022\037\n\tsubmitter\030\002 \001(\0132\014"
    ".keti.Entity\"-\n\003Ids\022\022\n\nsession_id\030\001 \001(\t\022"
    "\022\n\nmessage_id\030\002 \001(\005\"\333\002\n\026AvpVehicleAbnorm"
    "alData\022(\n\004time\030\001 \001(\0132\032.google.protobuf.T"
    "imestamp\0227\n\004type\030\002 \001(\0162).keti.AvpVehicle"
    "AbnormalData.AbnormalType\"\335\001\n\014AbnormalTy"
    "pe\022\020\n\014UNKNOWN_TYPE\020\000\022\022\n\016DRIVE_DIAGONAL\020\001"
    "\022\021\n\rDRIVE_REVERSE\020\002\022\026\n\022PARK_NON_PARK_ARE"
    "A\020\003\022\025\n\021PARK_STEP_ON_LINE\020\004\022\025\n\021DRIVE_SPEE"
    "D_LIMIT\020\005\022\023\n\017DRIVE_DOOR_OPEN\020\006\022\020\n\014IGNORE"
    "_ALARM\020\007\022\007\n\003SUA\020\010\022\016\n\nMEANDERING\020\t\022\016\n\nCOM"
    "M_ERROR\020\n\"J\n\034AvpVehicleAbnormalDataStrea"
    "m\022*\n\004data\030\001 \003(\0132\034.keti.AvpVehicleAbnorma"
    "lData\"\"\n\nAvpGridPos\022\t\n\001x\030\001 \001(\005\022\t\n\001y\030\002 \001("
    "\005\"O\n\rAvpVehiclePos\022\036\n\004pos1\030\001 \001(\0132\020.keti."
    "AvpGridPos\022\036\n\004pos2\030\002 \001(\0132\020.keti.AvpGridP"
    "os\":\n\nAvpVehicle\022 \n\003pos\030\001 \001(\0132\023.keti.Avp"
    "VehiclePos\022\n\n\002id\030\002 \001(\t\"\"\n\020AvpParkingSpac"
    "es\022\016\n\006parked\030\001 \003(\010\"\323\001\n\025AvpCCTVMonitoring"
    "Data\022(\n\004time\030\001 \001(\0132\032.google.protobuf.Tim"
    "estamp\022\"\n\010avp_cars\030\002 \003(\0132\020.keti.AvpVehic"
    "le\022\036\n\004cars\030\003 \003(\0132\020.keti.AvpVehicle\022$\n\007pe"
    "rsons\030\004 \003(\0132\023.keti.AvpVehiclePos\022&\n\006spac"
    "es\030\005 \001(\0132\026.keti.AvpParkingSpaces\"\223\002\n\027Avp"
    "VehicleParkingSensor\022\020\n\010FR_alarm\030\001 \001(\r\022\021"
    "\n\tFCS_alarm\030\002 \001(\r\022\021\n\tFLS_alarm\030\003 \001(\r\022\021\n\t"
    "FRS_alarm\030\004 \001(\r\022\016\n\006FI_ind\030\005 \001(\r\022\017\n\007FOL_i"
    "nd\030\006 \001(\r\022\017\n\007FOR_ind\030\007 \001(\r\022\020\n\010RR_alarm\030\010 "
    "\001(\r\022\021\n\tRCS_alarm\030\t \001(\r\022\021\n\tRLS_alarm\030\n \001("
    "\r\022\021\n\tRRS_alarm\030\013 \001(\r\022\016\n\006RI_ind\030\014 \001(\r\022\017\n\007"
    "ROL_ind\030\r \001(\r\022\017\n\007ROR_ind\030\016 \001(\r\"@\n\030AvpVeh"
    "icleSteeringSensor\022\021\n\tsas_angle\030\001 \001(\001\022\021\n"
    "\tsas_speed\030\002 \001(\001\"`\n\031AvpVehicleStabilityS"
    "ensor\022\025\n\resp_lat_accel\030\001 \001(\001\022\026\n\016esp_long"
    "_accel\030\002 \001(\001\022\024\n\014esp_yaw_rate\030\003 \001(\001\"%\n\024Av"
    "pVehicleDoorSensor\022\r\n\005front\030\001 \001(\005\"\374\001\n\020Av"
    "pCANSensorData\022(\n\004time\030\001 \001(\0132\032.google.pr"
    "otobuf.Timestamp\022.\n\007parking\030\002 \001(\0132\035.keti"
    ".AvpVehicleParkingSensor\0220\n\010steering\030\003 \001"
    "(\0132\036.keti.AvpVehicleSteeringSensor\0222\n\tst"
    "ability\030\004 \001(\0132\037.keti.AvpVehicleStability"
    "Sensor\022(\n\004door\030\005 \001(\0132\032.keti.AvpVehicleDo"
    "orSensor\"\350\001\n\021AvpControlMessage\022*\n\004type\030\001"
    " \001(\0162\034.keti.AvpControlMessage.Type\022*\n\004co"
    "de\030\002 \001(\0162\034.keti.AvpControlMessage.Code\"J"
    "\n\004Type\022\020\n\014UNKNOWN_TYPE\020\000\022\r\n\tREQ_RESET\020\001\022"
    "\017\n\013REQ_CONNECT\020\002\022\020\n\014RESP_CONNECT\020\003\"/\n\004Co"
    "de\022\020\n\014UNKNOWN_CODE\020\000\022\013\n\007SUCCESS\020\001\022\010\n\004FAI"
    "L\020\002\"6\n\016AvpDataMessage\022$\n\004data\030\001 \003(\0132\026.ke"
    "ti.AvpCANSensorData\"\237\001\n\nAvpMessage\022 \n\010en"
    "velope\030\001 \001(\0132\016.keti.Envelope\022\025\n\002id\030\002 \001(\013"
    "2\t.keti.Ids\022\'\n\004ctrl\030\003 \001(\0132\027.keti.AvpCont"
    "rolMessageH\000\022$\n\004data\030\004 \001(\0132\024.keti.AvpDat"
    "aMessageH\000B\t\n\007messageB\033\252\002\030Google.Protobu"
    "f.keti.Avpb\006proto3"
};
static const ::_pbi::DescriptorTable* const descriptor_table_Avp_2eproto_deps[1] =
    {
        &::descriptor_table_google_2fprotobuf_2ftimestamp_2eproto,
};
static ::absl::once_flag descriptor_table_Avp_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_Avp_2eproto = {
    false,
    false,
    2458,
    descriptor_table_protodef_Avp_2eproto,
    "Avp.proto",
    &descriptor_table_Avp_2eproto_once,
    descriptor_table_Avp_2eproto_deps,
    1,
    19,
    schemas,
    file_default_instances,
    TableStruct_Avp_2eproto::offsets,
    file_level_enum_descriptors_Avp_2eproto,
    file_level_service_descriptors_Avp_2eproto,
};
namespace keti {
const ::google::protobuf::EnumDescriptor* AvpVehicleAbnormalData_AbnormalType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Avp_2eproto);
  return file_level_enum_descriptors_Avp_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t AvpVehicleAbnormalData_AbnormalType_internal_data_[] = {
    720896u, 0u, };
bool AvpVehicleAbnormalData_AbnormalType_IsValid(int value) {
  return 0 <= value && value <= 10;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::UNKNOWN_TYPE;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::DRIVE_DIAGONAL;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::DRIVE_REVERSE;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::PARK_NON_PARK_AREA;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::PARK_STEP_ON_LINE;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::DRIVE_SPEED_LIMIT;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::DRIVE_DOOR_OPEN;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::IGNORE_ALARM;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::SUA;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::MEANDERING;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::COMM_ERROR;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::AbnormalType_MIN;
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::AbnormalType_MAX;
constexpr int AvpVehicleAbnormalData::AbnormalType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* AvpControlMessage_Type_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Avp_2eproto);
  return file_level_enum_descriptors_Avp_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t AvpControlMessage_Type_internal_data_[] = {
    262144u, 0u, };
bool AvpControlMessage_Type_IsValid(int value) {
  return 0 <= value && value <= 3;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr AvpControlMessage_Type AvpControlMessage::UNKNOWN_TYPE;
constexpr AvpControlMessage_Type AvpControlMessage::REQ_RESET;
constexpr AvpControlMessage_Type AvpControlMessage::REQ_CONNECT;
constexpr AvpControlMessage_Type AvpControlMessage::RESP_CONNECT;
constexpr AvpControlMessage_Type AvpControlMessage::Type_MIN;
constexpr AvpControlMessage_Type AvpControlMessage::Type_MAX;
constexpr int AvpControlMessage::Type_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::google::protobuf::EnumDescriptor* AvpControlMessage_Code_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_Avp_2eproto);
  return file_level_enum_descriptors_Avp_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t AvpControlMessage_Code_internal_data_[] = {
    196608u, 0u, };
bool AvpControlMessage_Code_IsValid(int value) {
  return 0 <= value && value <= 2;
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr AvpControlMessage_Code AvpControlMessage::UNKNOWN_CODE;
constexpr AvpControlMessage_Code AvpControlMessage::SUCCESS;
constexpr AvpControlMessage_Code AvpControlMessage::FAIL;
constexpr AvpControlMessage_Code AvpControlMessage::Code_MIN;
constexpr AvpControlMessage_Code AvpControlMessage::Code_MAX;
constexpr int AvpControlMessage::Code_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
// ===================================================================

class Version::_Internal {
 public:
};

Version::Version(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.Version)
}
Version::Version(
    ::google::protobuf::Arena* arena, const Version& from)
    : Version(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE Version::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Version::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, major_),
           0,
           offsetof(Impl_, patch_) -
               offsetof(Impl_, major_) +
               sizeof(Impl_::patch_));
}
Version::~Version() {
  // @@protoc_insertion_point(destructor:keti.Version)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Version::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Version::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_Version_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Version::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Version>(),
            ::google::protobuf::Message::GetNewImpl<Version>(),
            ::google::protobuf::Message::GetClearImpl<Version>(), &Version::ByteSizeLong,
                &Version::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Version, _impl_._cached_size_),
            false,
        },
        &Version::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Version::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> Version::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::Version>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 major = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Version, _impl_.major_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.major_)}},
    // uint32 minor = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Version, _impl_.minor_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.minor_)}},
    // uint32 patch = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Version, _impl_.patch_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(Version, _impl_.patch_)}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 major = 1;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.major_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 minor = 2;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.minor_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 patch = 3;
    {PROTOBUF_FIELD_OFFSET(Version, _impl_.patch_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.Version)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.major_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.patch_) -
      reinterpret_cast<char*>(&_impl_.major_)) + sizeof(_impl_.patch_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Version::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Version::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.Version)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 major = 1;
          if (this_._internal_major() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_major(), target);
          }

          // uint32 minor = 2;
          if (this_._internal_minor() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_minor(), target);
          }

          // uint32 patch = 3;
          if (this_._internal_patch() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_patch(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.Version)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Version::ByteSizeLong(const MessageLite& base) {
          const Version& this_ = static_cast<const Version&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Version::ByteSizeLong() const {
          const Version& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.Version)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // uint32 major = 1;
            if (this_._internal_major() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_major());
            }
            // uint32 minor = 2;
            if (this_._internal_minor() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_minor());
            }
            // uint32 patch = 3;
            if (this_._internal_patch() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_patch());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Version::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.Version)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_major() != 0) {
    _this->_impl_.major_ = from._impl_.major_;
  }
  if (from._internal_minor() != 0) {
    _this->_impl_.minor_ = from._impl_.minor_;
  }
  if (from._internal_patch() != 0) {
    _this->_impl_.patch_ = from._impl_.patch_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Version::InternalSwap(Version* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Version, _impl_.patch_)
      + sizeof(Version::_impl_.patch_)
      - PROTOBUF_FIELD_OFFSET(Version, _impl_.major_)>(
          reinterpret_cast<char*>(&_impl_.major_),
          reinterpret_cast<char*>(&other->_impl_.major_));
}

::google::protobuf::Metadata Version::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Entity::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Entity>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Entity, _impl_._has_bits_);
};

Entity::Entity(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.Entity)
}
inline PROTOBUF_NDEBUG_INLINE Entity::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::Entity& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        primary_id_(arena, from.primary_id_),
        secondary_id_(arena, from.secondary_id_),
        type_(arena, from.type_) {}

Entity::Entity(
    ::google::protobuf::Arena* arena,
    const Entity& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Entity* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.software_version_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::keti::Version>(
                              arena, *from._impl_.software_version_)
                        : nullptr;
  _impl_.hardware_version_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::Version>(
                              arena, *from._impl_.hardware_version_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.Entity)
}
inline PROTOBUF_NDEBUG_INLINE Entity::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        primary_id_(arena),
        secondary_id_(arena),
        type_(arena) {}

inline void Entity::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, software_version_),
           0,
           offsetof(Impl_, hardware_version_) -
               offsetof(Impl_, software_version_) +
               sizeof(Impl_::hardware_version_));
}
Entity::~Entity() {
  // @@protoc_insertion_point(destructor:keti.Entity)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Entity::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.primary_id_.Destroy();
  _impl_.secondary_id_.Destroy();
  _impl_.type_.Destroy();
  delete _impl_.software_version_;
  delete _impl_.hardware_version_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Entity::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_Entity_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Entity::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Entity>(),
            ::google::protobuf::Message::GetNewImpl<Entity>(),
            ::google::protobuf::Message::GetClearImpl<Entity>(), &Entity::ByteSizeLong,
                &Entity::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Entity, _impl_._cached_size_),
            false,
        },
        &Entity::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Entity::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 2, 46, 2> Entity::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Entity, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::Entity>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string primary_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Entity, _impl_.primary_id_)}},
    // string secondary_id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Entity, _impl_.secondary_id_)}},
    // string type = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 63, 0, PROTOBUF_FIELD_OFFSET(Entity, _impl_.type_)}},
    // .keti.Version software_version = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 0, 0, PROTOBUF_FIELD_OFFSET(Entity, _impl_.software_version_)}},
    // .keti.Version hardware_version = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 1, PROTOBUF_FIELD_OFFSET(Entity, _impl_.hardware_version_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string primary_id = 1;
    {PROTOBUF_FIELD_OFFSET(Entity, _impl_.primary_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string secondary_id = 2;
    {PROTOBUF_FIELD_OFFSET(Entity, _impl_.secondary_id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string type = 3;
    {PROTOBUF_FIELD_OFFSET(Entity, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .keti.Version software_version = 4;
    {PROTOBUF_FIELD_OFFSET(Entity, _impl_.software_version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.Version hardware_version = 5;
    {PROTOBUF_FIELD_OFFSET(Entity, _impl_.hardware_version_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::Version>()},
    {::_pbi::TcParser::GetTable<::keti::Version>()},
  }}, {{
    "\13\12\14\4\0\0\0\0"
    "keti.Entity"
    "primary_id"
    "secondary_id"
    "type"
  }},
};

PROTOBUF_NOINLINE void Entity::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.Entity)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.primary_id_.ClearToEmpty();
  _impl_.secondary_id_.ClearToEmpty();
  _impl_.type_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.software_version_ != nullptr);
      _impl_.software_version_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.hardware_version_ != nullptr);
      _impl_.hardware_version_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Entity::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Entity& this_ = static_cast<const Entity&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Entity::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Entity& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.Entity)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string primary_id = 1;
          if (!this_._internal_primary_id().empty()) {
            const std::string& _s = this_._internal_primary_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "keti.Entity.primary_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string secondary_id = 2;
          if (!this_._internal_secondary_id().empty()) {
            const std::string& _s = this_._internal_secondary_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "keti.Entity.secondary_id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string type = 3;
          if (!this_._internal_type().empty()) {
            const std::string& _s = this_._internal_type();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "keti.Entity.type");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          cached_has_bits = this_._impl_._has_bits_[0];
          // .keti.Version software_version = 4;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.software_version_, this_._impl_.software_version_->GetCachedSize(), target,
                stream);
          }

          // .keti.Version hardware_version = 5;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.hardware_version_, this_._impl_.hardware_version_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.Entity)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Entity::ByteSizeLong(const MessageLite& base) {
          const Entity& this_ = static_cast<const Entity&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Entity::ByteSizeLong() const {
          const Entity& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.Entity)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string primary_id = 1;
            if (!this_._internal_primary_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_primary_id());
            }
            // string secondary_id = 2;
            if (!this_._internal_secondary_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_secondary_id());
            }
            // string type = 3;
            if (!this_._internal_type().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_type());
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .keti.Version software_version = 4;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.software_version_);
            }
            // .keti.Version hardware_version = 5;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.hardware_version_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Entity::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Entity*>(&to_msg);
  auto& from = static_cast<const Entity&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.Entity)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_primary_id().empty()) {
    _this->_internal_set_primary_id(from._internal_primary_id());
  }
  if (!from._internal_secondary_id().empty()) {
    _this->_internal_set_secondary_id(from._internal_secondary_id());
  }
  if (!from._internal_type().empty()) {
    _this->_internal_set_type(from._internal_type());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.software_version_ != nullptr);
      if (_this->_impl_.software_version_ == nullptr) {
        _this->_impl_.software_version_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Version>(arena, *from._impl_.software_version_);
      } else {
        _this->_impl_.software_version_->MergeFrom(*from._impl_.software_version_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.hardware_version_ != nullptr);
      if (_this->_impl_.hardware_version_ == nullptr) {
        _this->_impl_.hardware_version_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Version>(arena, *from._impl_.hardware_version_);
      } else {
        _this->_impl_.hardware_version_->MergeFrom(*from._impl_.hardware_version_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Entity::CopyFrom(const Entity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.Entity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Entity::InternalSwap(Entity* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.primary_id_, &other->_impl_.primary_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.secondary_id_, &other->_impl_.secondary_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.type_, &other->_impl_.type_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Entity, _impl_.hardware_version_)
      + sizeof(Entity::_impl_.hardware_version_)
      - PROTOBUF_FIELD_OFFSET(Entity, _impl_.software_version_)>(
          reinterpret_cast<char*>(&_impl_.software_version_),
          reinterpret_cast<char*>(&other->_impl_.software_version_));
}

::google::protobuf::Metadata Entity::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Envelope::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Envelope>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Envelope, _impl_._has_bits_);
};

Envelope::Envelope(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.Envelope)
}
inline PROTOBUF_NDEBUG_INLINE Envelope::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::Envelope& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Envelope::Envelope(
    ::google::protobuf::Arena* arena,
    const Envelope& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Envelope* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.version_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::keti::Version>(
                              arena, *from._impl_.version_)
                        : nullptr;
  _impl_.submitter_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::Entity>(
                              arena, *from._impl_.submitter_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.Envelope)
}
inline PROTOBUF_NDEBUG_INLINE Envelope::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Envelope::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, version_),
           0,
           offsetof(Impl_, submitter_) -
               offsetof(Impl_, version_) +
               sizeof(Impl_::submitter_));
}
Envelope::~Envelope() {
  // @@protoc_insertion_point(destructor:keti.Envelope)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Envelope::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.version_;
  delete _impl_.submitter_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Envelope::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_Envelope_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Envelope::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Envelope>(),
            ::google::protobuf::Message::GetNewImpl<Envelope>(),
            ::google::protobuf::Message::GetClearImpl<Envelope>(), &Envelope::ByteSizeLong,
                &Envelope::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Envelope, _impl_._cached_size_),
            false,
        },
        &Envelope::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Envelope::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> Envelope::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Envelope, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::Envelope>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .keti.Entity submitter = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Envelope, _impl_.submitter_)}},
    // .keti.Version version = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Envelope, _impl_.version_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .keti.Version version = 1;
    {PROTOBUF_FIELD_OFFSET(Envelope, _impl_.version_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.Entity submitter = 2;
    {PROTOBUF_FIELD_OFFSET(Envelope, _impl_.submitter_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::Version>()},
    {::_pbi::TcParser::GetTable<::keti::Entity>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Envelope::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.Envelope)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.version_ != nullptr);
      _impl_.version_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.submitter_ != nullptr);
      _impl_.submitter_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Envelope::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Envelope& this_ = static_cast<const Envelope&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Envelope::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Envelope& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.Envelope)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .keti.Version version = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.version_, this_._impl_.version_->GetCachedSize(), target,
                stream);
          }

          // .keti.Entity submitter = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.submitter_, this_._impl_.submitter_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.Envelope)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Envelope::ByteSizeLong(const MessageLite& base) {
          const Envelope& this_ = static_cast<const Envelope&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Envelope::ByteSizeLong() const {
          const Envelope& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.Envelope)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .keti.Version version = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.version_);
            }
            // .keti.Entity submitter = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.submitter_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Envelope::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Envelope*>(&to_msg);
  auto& from = static_cast<const Envelope&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.Envelope)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.version_ != nullptr);
      if (_this->_impl_.version_ == nullptr) {
        _this->_impl_.version_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Version>(arena, *from._impl_.version_);
      } else {
        _this->_impl_.version_->MergeFrom(*from._impl_.version_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.submitter_ != nullptr);
      if (_this->_impl_.submitter_ == nullptr) {
        _this->_impl_.submitter_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Entity>(arena, *from._impl_.submitter_);
      } else {
        _this->_impl_.submitter_->MergeFrom(*from._impl_.submitter_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Envelope::CopyFrom(const Envelope& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.Envelope)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Envelope::InternalSwap(Envelope* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Envelope, _impl_.submitter_)
      + sizeof(Envelope::_impl_.submitter_)
      - PROTOBUF_FIELD_OFFSET(Envelope, _impl_.version_)>(
          reinterpret_cast<char*>(&_impl_.version_),
          reinterpret_cast<char*>(&other->_impl_.version_));
}

::google::protobuf::Metadata Envelope::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Ids::_Internal {
 public:
};

Ids::Ids(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.Ids)
}
inline PROTOBUF_NDEBUG_INLINE Ids::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::Ids& from_msg)
      : session_id_(arena, from.session_id_),
        _cached_size_{0} {}

Ids::Ids(
    ::google::protobuf::Arena* arena,
    const Ids& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Ids* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.message_id_ = from._impl_.message_id_;

  // @@protoc_insertion_point(copy_constructor:keti.Ids)
}
inline PROTOBUF_NDEBUG_INLINE Ids::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : session_id_(arena),
        _cached_size_{0} {}

inline void Ids::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.message_id_ = {};
}
Ids::~Ids() {
  // @@protoc_insertion_point(destructor:keti.Ids)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void Ids::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.session_id_.Destroy();
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    Ids::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_Ids_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &Ids::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<Ids>(),
            ::google::protobuf::Message::GetNewImpl<Ids>(),
            ::google::protobuf::Message::GetClearImpl<Ids>(), &Ids::ByteSizeLong,
                &Ids::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(Ids, _impl_._cached_size_),
            false,
        },
        &Ids::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* Ids::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 27, 2> Ids::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::Ids>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 message_id = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(Ids, _impl_.message_id_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(Ids, _impl_.message_id_)}},
    // string session_id = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(Ids, _impl_.session_id_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string session_id = 1;
    {PROTOBUF_FIELD_OFFSET(Ids, _impl_.session_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // int32 message_id = 2;
    {PROTOBUF_FIELD_OFFSET(Ids, _impl_.message_id_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
    "\10\12\0\0\0\0\0\0"
    "keti.Ids"
    "session_id"
  }},
};

PROTOBUF_NOINLINE void Ids::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.Ids)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.session_id_.ClearToEmpty();
  _impl_.message_id_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Ids::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Ids& this_ = static_cast<const Ids&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Ids::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Ids& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.Ids)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // string session_id = 1;
          if (!this_._internal_session_id().empty()) {
            const std::string& _s = this_._internal_session_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "keti.Ids.session_id");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // int32 message_id = 2;
          if (this_._internal_message_id() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<2>(
                    stream, this_._internal_message_id(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.Ids)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Ids::ByteSizeLong(const MessageLite& base) {
          const Ids& this_ = static_cast<const Ids&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Ids::ByteSizeLong() const {
          const Ids& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.Ids)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string session_id = 1;
            if (!this_._internal_session_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_session_id());
            }
            // int32 message_id = 2;
            if (this_._internal_message_id() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_message_id());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Ids::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Ids*>(&to_msg);
  auto& from = static_cast<const Ids&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.Ids)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_session_id().empty()) {
    _this->_internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_message_id() != 0) {
    _this->_impl_.message_id_ = from._impl_.message_id_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Ids::CopyFrom(const Ids& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.Ids)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Ids::InternalSwap(Ids* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.session_id_, &other->_impl_.session_id_, arena);
        swap(_impl_.message_id_, other->_impl_.message_id_);
}

::google::protobuf::Metadata Ids::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleAbnormalData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpVehicleAbnormalData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_._has_bits_);
};

void AvpVehicleAbnormalData::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AvpVehicleAbnormalData::AvpVehicleAbnormalData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleAbnormalData)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleAbnormalData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpVehicleAbnormalData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

AvpVehicleAbnormalData::AvpVehicleAbnormalData(
    ::google::protobuf::Arena* arena,
    const AvpVehicleAbnormalData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpVehicleAbnormalData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.time_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(
                              arena, *from._impl_.time_)
                        : nullptr;
  _impl_.type_ = from._impl_.type_;

  // @@protoc_insertion_point(copy_constructor:keti.AvpVehicleAbnormalData)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleAbnormalData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehicleAbnormalData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           0,
           offsetof(Impl_, type_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::type_));
}
AvpVehicleAbnormalData::~AvpVehicleAbnormalData() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleAbnormalData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleAbnormalData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.time_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleAbnormalData::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleAbnormalData_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleAbnormalData::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleAbnormalData>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleAbnormalData>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleAbnormalData>(), &AvpVehicleAbnormalData::ByteSizeLong,
                &AvpVehicleAbnormalData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_._cached_size_),
            false,
        },
        &AvpVehicleAbnormalData::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleAbnormalData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 0, 2> AvpVehicleAbnormalData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleAbnormalData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleAbnormalData, _impl_.type_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.type_)}},
    // .google.protobuf.Timestamp time = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.time_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Timestamp time = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.time_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.type_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleAbnormalData::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleAbnormalData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.time_ != nullptr);
    _impl_.time_->Clear();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleAbnormalData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleAbnormalData& this_ = static_cast<const AvpVehicleAbnormalData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleAbnormalData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleAbnormalData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleAbnormalData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .google.protobuf.Timestamp time = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.time_, this_._impl_.time_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_type(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleAbnormalData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleAbnormalData::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleAbnormalData& this_ = static_cast<const AvpVehicleAbnormalData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleAbnormalData::ByteSizeLong() const {
          const AvpVehicleAbnormalData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleAbnormalData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .google.protobuf.Timestamp time = 1;
            cached_has_bits =
                this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.time_);
            }
          }
           {
            // .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleAbnormalData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleAbnormalData*>(&to_msg);
  auto& from = static_cast<const AvpVehicleAbnormalData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleAbnormalData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.time_ != nullptr);
    if (_this->_impl_.time_ == nullptr) {
      _this->_impl_.time_ =
          ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.time_);
    } else {
      _this->_impl_.time_->MergeFrom(*from._impl_.time_);
    }
  }
  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleAbnormalData::CopyFrom(const AvpVehicleAbnormalData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleAbnormalData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleAbnormalData::InternalSwap(AvpVehicleAbnormalData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.type_)
      + sizeof(AvpVehicleAbnormalData::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalData, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::google::protobuf::Metadata AvpVehicleAbnormalData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleAbnormalDataStream::_Internal {
 public:
};

AvpVehicleAbnormalDataStream::AvpVehicleAbnormalDataStream(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleAbnormalDataStream)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleAbnormalDataStream::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpVehicleAbnormalDataStream& from_msg)
      : data_{visibility, arena, from.data_},
        _cached_size_{0} {}

AvpVehicleAbnormalDataStream::AvpVehicleAbnormalDataStream(
    ::google::protobuf::Arena* arena,
    const AvpVehicleAbnormalDataStream& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpVehicleAbnormalDataStream* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:keti.AvpVehicleAbnormalDataStream)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleAbnormalDataStream::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : data_{visibility, arena},
        _cached_size_{0} {}

inline void AvpVehicleAbnormalDataStream::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AvpVehicleAbnormalDataStream::~AvpVehicleAbnormalDataStream() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleAbnormalDataStream)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleAbnormalDataStream::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleAbnormalDataStream::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleAbnormalDataStream_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleAbnormalDataStream::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleAbnormalDataStream>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleAbnormalDataStream>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleAbnormalDataStream>(), &AvpVehicleAbnormalDataStream::ByteSizeLong,
                &AvpVehicleAbnormalDataStream::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalDataStream, _impl_._cached_size_),
            false,
        },
        &AvpVehicleAbnormalDataStream::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleAbnormalDataStream::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> AvpVehicleAbnormalDataStream::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleAbnormalDataStream>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .keti.AvpVehicleAbnormalData data = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalDataStream, _impl_.data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .keti.AvpVehicleAbnormalData data = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleAbnormalDataStream, _impl_.data_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::AvpVehicleAbnormalData>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleAbnormalDataStream::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleAbnormalDataStream)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleAbnormalDataStream::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleAbnormalDataStream& this_ = static_cast<const AvpVehicleAbnormalDataStream&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleAbnormalDataStream::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleAbnormalDataStream& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleAbnormalDataStream)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .keti.AvpVehicleAbnormalData data = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_data_size());
               i < n; i++) {
            const auto& repfield = this_._internal_data().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleAbnormalDataStream)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleAbnormalDataStream::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleAbnormalDataStream& this_ = static_cast<const AvpVehicleAbnormalDataStream&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleAbnormalDataStream::ByteSizeLong() const {
          const AvpVehicleAbnormalDataStream& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleAbnormalDataStream)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .keti.AvpVehicleAbnormalData data = 1;
             {
              total_size += 1UL * this_._internal_data_size();
              for (const auto& msg : this_._internal_data()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleAbnormalDataStream::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleAbnormalDataStream*>(&to_msg);
  auto& from = static_cast<const AvpVehicleAbnormalDataStream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleAbnormalDataStream)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_data()->MergeFrom(
      from._internal_data());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleAbnormalDataStream::CopyFrom(const AvpVehicleAbnormalDataStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleAbnormalDataStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleAbnormalDataStream::InternalSwap(AvpVehicleAbnormalDataStream* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
}

::google::protobuf::Metadata AvpVehicleAbnormalDataStream::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpGridPos::_Internal {
 public:
};

AvpGridPos::AvpGridPos(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpGridPos)
}
AvpGridPos::AvpGridPos(
    ::google::protobuf::Arena* arena, const AvpGridPos& from)
    : AvpGridPos(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpGridPos::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpGridPos::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, x_),
           0,
           offsetof(Impl_, y_) -
               offsetof(Impl_, x_) +
               sizeof(Impl_::y_));
}
AvpGridPos::~AvpGridPos() {
  // @@protoc_insertion_point(destructor:keti.AvpGridPos)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpGridPos::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpGridPos::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpGridPos_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpGridPos::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpGridPos>(),
            ::google::protobuf::Message::GetNewImpl<AvpGridPos>(),
            ::google::protobuf::Message::GetClearImpl<AvpGridPos>(), &AvpGridPos::ByteSizeLong,
                &AvpGridPos::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_._cached_size_),
            false,
        },
        &AvpGridPos::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpGridPos::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AvpGridPos::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpGridPos>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 y = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpGridPos, _impl_.y_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.y_)}},
    // int32 x = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpGridPos, _impl_.x_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.x_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 x = 1;
    {PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.x_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
    // int32 y = 2;
    {PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.y_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpGridPos::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpGridPos)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpGridPos::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpGridPos& this_ = static_cast<const AvpGridPos&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpGridPos::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpGridPos& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpGridPos)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // int32 x = 1;
          if (this_._internal_x() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<1>(
                    stream, this_._internal_x(), target);
          }

          // int32 y = 2;
          if (this_._internal_y() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<2>(
                    stream, this_._internal_y(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpGridPos)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpGridPos::ByteSizeLong(const MessageLite& base) {
          const AvpGridPos& this_ = static_cast<const AvpGridPos&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpGridPos::ByteSizeLong() const {
          const AvpGridPos& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpGridPos)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // int32 x = 1;
            if (this_._internal_x() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_x());
            }
            // int32 y = 2;
            if (this_._internal_y() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_y());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpGridPos::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpGridPos*>(&to_msg);
  auto& from = static_cast<const AvpGridPos&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpGridPos)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_x() != 0) {
    _this->_impl_.x_ = from._impl_.x_;
  }
  if (from._internal_y() != 0) {
    _this->_impl_.y_ = from._impl_.y_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpGridPos::CopyFrom(const AvpGridPos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpGridPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpGridPos::InternalSwap(AvpGridPos* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.y_)
      + sizeof(AvpGridPos::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(AvpGridPos, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::google::protobuf::Metadata AvpGridPos::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehiclePos::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpVehiclePos>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_._has_bits_);
};

AvpVehiclePos::AvpVehiclePos(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehiclePos)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehiclePos::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpVehiclePos& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

AvpVehiclePos::AvpVehiclePos(
    ::google::protobuf::Arena* arena,
    const AvpVehiclePos& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpVehiclePos* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pos1_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpGridPos>(
                              arena, *from._impl_.pos1_)
                        : nullptr;
  _impl_.pos2_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpGridPos>(
                              arena, *from._impl_.pos2_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.AvpVehiclePos)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehiclePos::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehiclePos::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, pos1_),
           0,
           offsetof(Impl_, pos2_) -
               offsetof(Impl_, pos1_) +
               sizeof(Impl_::pos2_));
}
AvpVehiclePos::~AvpVehiclePos() {
  // @@protoc_insertion_point(destructor:keti.AvpVehiclePos)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehiclePos::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.pos1_;
  delete _impl_.pos2_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehiclePos::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehiclePos_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehiclePos::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehiclePos>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehiclePos>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehiclePos>(), &AvpVehiclePos::ByteSizeLong,
                &AvpVehiclePos::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_._cached_size_),
            false,
        },
        &AvpVehiclePos::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehiclePos::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 2, 0, 2> AvpVehiclePos::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    2,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehiclePos>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .keti.AvpGridPos pos2 = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos2_)}},
    // .keti.AvpGridPos pos1 = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos1_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .keti.AvpGridPos pos1 = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos1_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpGridPos pos2 = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos2_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::AvpGridPos>()},
    {::_pbi::TcParser::GetTable<::keti::AvpGridPos>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpVehiclePos::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehiclePos)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.pos1_ != nullptr);
      _impl_.pos1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.pos2_ != nullptr);
      _impl_.pos2_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehiclePos::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehiclePos& this_ = static_cast<const AvpVehiclePos&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehiclePos::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehiclePos& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehiclePos)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .keti.AvpGridPos pos1 = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.pos1_, this_._impl_.pos1_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpGridPos pos2 = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.pos2_, this_._impl_.pos2_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehiclePos)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehiclePos::ByteSizeLong(const MessageLite& base) {
          const AvpVehiclePos& this_ = static_cast<const AvpVehiclePos&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehiclePos::ByteSizeLong() const {
          const AvpVehiclePos& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehiclePos)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .keti.AvpGridPos pos1 = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pos1_);
            }
            // .keti.AvpGridPos pos2 = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pos2_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehiclePos::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehiclePos*>(&to_msg);
  auto& from = static_cast<const AvpVehiclePos&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehiclePos)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.pos1_ != nullptr);
      if (_this->_impl_.pos1_ == nullptr) {
        _this->_impl_.pos1_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpGridPos>(arena, *from._impl_.pos1_);
      } else {
        _this->_impl_.pos1_->MergeFrom(*from._impl_.pos1_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.pos2_ != nullptr);
      if (_this->_impl_.pos2_ == nullptr) {
        _this->_impl_.pos2_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpGridPos>(arena, *from._impl_.pos2_);
      } else {
        _this->_impl_.pos2_->MergeFrom(*from._impl_.pos2_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehiclePos::CopyFrom(const AvpVehiclePos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehiclePos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehiclePos::InternalSwap(AvpVehiclePos* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos2_)
      + sizeof(AvpVehiclePos::_impl_.pos2_)
      - PROTOBUF_FIELD_OFFSET(AvpVehiclePos, _impl_.pos1_)>(
          reinterpret_cast<char*>(&_impl_.pos1_),
          reinterpret_cast<char*>(&other->_impl_.pos1_));
}

::google::protobuf::Metadata AvpVehiclePos::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicle::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpVehicle>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_._has_bits_);
};

AvpVehicle::AvpVehicle(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicle)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicle::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpVehicle& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        id_(arena, from.id_) {}

AvpVehicle::AvpVehicle(
    ::google::protobuf::Arena* arena,
    const AvpVehicle& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpVehicle* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.pos_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpVehiclePos>(
                              arena, *from._impl_.pos_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.AvpVehicle)
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicle::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        id_(arena) {}

inline void AvpVehicle::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.pos_ = {};
}
AvpVehicle::~AvpVehicle() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicle)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicle::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.id_.Destroy();
  delete _impl_.pos_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicle::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicle_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicle::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicle>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicle>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicle>(), &AvpVehicle::ByteSizeLong,
                &AvpVehicle::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_._cached_size_),
            false,
        },
        &AvpVehicle::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicle::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 26, 2> AvpVehicle::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicle>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string id = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_.id_)}},
    // .keti.AvpVehiclePos pos = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_.pos_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .keti.AvpVehiclePos pos = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_.pos_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // string id = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehicle, _impl_.id_), -1, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::AvpVehiclePos>()},
  }}, {{
    "\17\0\2\0\0\0\0\0"
    "keti.AvpVehicle"
    "id"
  }},
};

PROTOBUF_NOINLINE void AvpVehicle::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicle)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.id_.ClearToEmpty();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicle::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicle& this_ = static_cast<const AvpVehicle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicle::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicle)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .keti.AvpVehiclePos pos = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.pos_, this_._impl_.pos_->GetCachedSize(), target,
                stream);
          }

          // string id = 2;
          if (!this_._internal_id().empty()) {
            const std::string& _s = this_._internal_id();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "keti.AvpVehicle.id");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicle)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicle::ByteSizeLong(const MessageLite& base) {
          const AvpVehicle& this_ = static_cast<const AvpVehicle&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicle::ByteSizeLong() const {
          const AvpVehicle& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicle)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // string id = 2;
            if (!this_._internal_id().empty()) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_id());
            }
          }
           {
            // .keti.AvpVehiclePos pos = 1;
            cached_has_bits =
                this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.pos_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicle::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicle*>(&to_msg);
  auto& from = static_cast<const AvpVehicle&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicle)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_id().empty()) {
    _this->_internal_set_id(from._internal_id());
  }
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ABSL_DCHECK(from._impl_.pos_ != nullptr);
    if (_this->_impl_.pos_ == nullptr) {
      _this->_impl_.pos_ =
          ::google::protobuf::Message::CopyConstruct<::keti::AvpVehiclePos>(arena, *from._impl_.pos_);
    } else {
      _this->_impl_.pos_->MergeFrom(*from._impl_.pos_);
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicle::CopyFrom(const AvpVehicle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicle::InternalSwap(AvpVehicle* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.id_, &other->_impl_.id_, arena);
  swap(_impl_.pos_, other->_impl_.pos_);
}

::google::protobuf::Metadata AvpVehicle::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpParkingSpaces::_Internal {
 public:
};

AvpParkingSpaces::AvpParkingSpaces(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpParkingSpaces)
}
inline PROTOBUF_NDEBUG_INLINE AvpParkingSpaces::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpParkingSpaces& from_msg)
      : parked_{visibility, arena, from.parked_},
        _cached_size_{0} {}

AvpParkingSpaces::AvpParkingSpaces(
    ::google::protobuf::Arena* arena,
    const AvpParkingSpaces& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpParkingSpaces* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:keti.AvpParkingSpaces)
}
inline PROTOBUF_NDEBUG_INLINE AvpParkingSpaces::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : parked_{visibility, arena},
        _cached_size_{0} {}

inline void AvpParkingSpaces::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AvpParkingSpaces::~AvpParkingSpaces() {
  // @@protoc_insertion_point(destructor:keti.AvpParkingSpaces)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpParkingSpaces::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpParkingSpaces::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpParkingSpaces_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpParkingSpaces::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpParkingSpaces>(),
            ::google::protobuf::Message::GetNewImpl<AvpParkingSpaces>(),
            ::google::protobuf::Message::GetClearImpl<AvpParkingSpaces>(), &AvpParkingSpaces::ByteSizeLong,
                &AvpParkingSpaces::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpParkingSpaces, _impl_._cached_size_),
            false,
        },
        &AvpParkingSpaces::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpParkingSpaces::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> AvpParkingSpaces::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpParkingSpaces>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated bool parked = 1;
    {::_pbi::TcParser::FastV8P1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AvpParkingSpaces, _impl_.parked_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated bool parked = 1;
    {PROTOBUF_FIELD_OFFSET(AvpParkingSpaces, _impl_.parked_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpParkingSpaces::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpParkingSpaces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.parked_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpParkingSpaces::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpParkingSpaces& this_ = static_cast<const AvpParkingSpaces&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpParkingSpaces::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpParkingSpaces& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpParkingSpaces)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated bool parked = 1;
          if (this_._internal_parked_size() > 0) {
            target = stream->WriteFixedPacked(1, this_._internal_parked(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpParkingSpaces)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpParkingSpaces::ByteSizeLong(const MessageLite& base) {
          const AvpParkingSpaces& this_ = static_cast<const AvpParkingSpaces&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpParkingSpaces::ByteSizeLong() const {
          const AvpParkingSpaces& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpParkingSpaces)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated bool parked = 1;
             {
              std::size_t data_size = std::size_t{1} *
                  ::_pbi::FromIntSize(this_._internal_parked_size())
              ;
              std::size_t tag_size = data_size == 0
                  ? 0
                  : 1 + ::_pbi::WireFormatLite::Int32Size(
                                      static_cast<int32_t>(data_size))
              ;
              total_size += tag_size + data_size;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpParkingSpaces::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpParkingSpaces*>(&to_msg);
  auto& from = static_cast<const AvpParkingSpaces&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpParkingSpaces)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_parked()->MergeFrom(from._internal_parked());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpParkingSpaces::CopyFrom(const AvpParkingSpaces& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpParkingSpaces)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpParkingSpaces::InternalSwap(AvpParkingSpaces* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.parked_.InternalSwap(&other->_impl_.parked_);
}

::google::protobuf::Metadata AvpParkingSpaces::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpCCTVMonitoringData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpCCTVMonitoringData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_._has_bits_);
};

void AvpCCTVMonitoringData::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AvpCCTVMonitoringData::AvpCCTVMonitoringData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpCCTVMonitoringData)
}
inline PROTOBUF_NDEBUG_INLINE AvpCCTVMonitoringData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpCCTVMonitoringData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        avp_cars_{visibility, arena, from.avp_cars_},
        cars_{visibility, arena, from.cars_},
        persons_{visibility, arena, from.persons_} {}

AvpCCTVMonitoringData::AvpCCTVMonitoringData(
    ::google::protobuf::Arena* arena,
    const AvpCCTVMonitoringData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpCCTVMonitoringData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.time_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(
                              arena, *from._impl_.time_)
                        : nullptr;
  _impl_.spaces_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpParkingSpaces>(
                              arena, *from._impl_.spaces_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.AvpCCTVMonitoringData)
}
inline PROTOBUF_NDEBUG_INLINE AvpCCTVMonitoringData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        avp_cars_{visibility, arena},
        cars_{visibility, arena},
        persons_{visibility, arena} {}

inline void AvpCCTVMonitoringData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           0,
           offsetof(Impl_, spaces_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::spaces_));
}
AvpCCTVMonitoringData::~AvpCCTVMonitoringData() {
  // @@protoc_insertion_point(destructor:keti.AvpCCTVMonitoringData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpCCTVMonitoringData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.time_;
  delete _impl_.spaces_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpCCTVMonitoringData::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpCCTVMonitoringData_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpCCTVMonitoringData::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpCCTVMonitoringData>(),
            ::google::protobuf::Message::GetNewImpl<AvpCCTVMonitoringData>(),
            ::google::protobuf::Message::GetClearImpl<AvpCCTVMonitoringData>(), &AvpCCTVMonitoringData::ByteSizeLong,
                &AvpCCTVMonitoringData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_._cached_size_),
            false,
        },
        &AvpCCTVMonitoringData::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpCCTVMonitoringData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> AvpCCTVMonitoringData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpCCTVMonitoringData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Timestamp time = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.time_)}},
    // repeated .keti.AvpVehicle avp_cars = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 1, PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.avp_cars_)}},
    // repeated .keti.AvpVehicle cars = 3;
    {::_pbi::TcParser::FastMtR1,
     {26, 63, 2, PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.cars_)}},
    // repeated .keti.AvpVehiclePos persons = 4;
    {::_pbi::TcParser::FastMtR1,
     {34, 63, 3, PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.persons_)}},
    // .keti.AvpParkingSpaces spaces = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 1, 4, PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.spaces_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Timestamp time = 1;
    {PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.time_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .keti.AvpVehicle avp_cars = 2;
    {PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.avp_cars_), -1, 1,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .keti.AvpVehicle cars = 3;
    {PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.cars_), -1, 2,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // repeated .keti.AvpVehiclePos persons = 4;
    {PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.persons_), -1, 3,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpParkingSpaces spaces = 5;
    {PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.spaces_), _Internal::kHasBitsOffset + 1, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicle>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicle>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehiclePos>()},
    {::_pbi::TcParser::GetTable<::keti::AvpParkingSpaces>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpCCTVMonitoringData::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpCCTVMonitoringData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.avp_cars_.Clear();
  _impl_.cars_.Clear();
  _impl_.persons_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.spaces_ != nullptr);
      _impl_.spaces_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpCCTVMonitoringData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpCCTVMonitoringData& this_ = static_cast<const AvpCCTVMonitoringData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpCCTVMonitoringData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpCCTVMonitoringData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpCCTVMonitoringData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .google.protobuf.Timestamp time = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.time_, this_._impl_.time_->GetCachedSize(), target,
                stream);
          }

          // repeated .keti.AvpVehicle avp_cars = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_avp_cars_size());
               i < n; i++) {
            const auto& repfield = this_._internal_avp_cars().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .keti.AvpVehicle cars = 3;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_cars_size());
               i < n; i++) {
            const auto& repfield = this_._internal_cars().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    3, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // repeated .keti.AvpVehiclePos persons = 4;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_persons_size());
               i < n; i++) {
            const auto& repfield = this_._internal_persons().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    4, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // .keti.AvpParkingSpaces spaces = 5;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.spaces_, this_._impl_.spaces_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpCCTVMonitoringData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpCCTVMonitoringData::ByteSizeLong(const MessageLite& base) {
          const AvpCCTVMonitoringData& this_ = static_cast<const AvpCCTVMonitoringData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpCCTVMonitoringData::ByteSizeLong() const {
          const AvpCCTVMonitoringData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpCCTVMonitoringData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .keti.AvpVehicle avp_cars = 2;
             {
              total_size += 1UL * this_._internal_avp_cars_size();
              for (const auto& msg : this_._internal_avp_cars()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .keti.AvpVehicle cars = 3;
             {
              total_size += 1UL * this_._internal_cars_size();
              for (const auto& msg : this_._internal_cars()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
            // repeated .keti.AvpVehiclePos persons = 4;
             {
              total_size += 1UL * this_._internal_persons_size();
              for (const auto& msg : this_._internal_persons()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .google.protobuf.Timestamp time = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.time_);
            }
            // .keti.AvpParkingSpaces spaces = 5;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.spaces_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpCCTVMonitoringData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpCCTVMonitoringData*>(&to_msg);
  auto& from = static_cast<const AvpCCTVMonitoringData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpCCTVMonitoringData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_avp_cars()->MergeFrom(
      from._internal_avp_cars());
  _this->_internal_mutable_cars()->MergeFrom(
      from._internal_cars());
  _this->_internal_mutable_persons()->MergeFrom(
      from._internal_persons());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.time_ != nullptr);
      if (_this->_impl_.time_ == nullptr) {
        _this->_impl_.time_ =
            ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.time_);
      } else {
        _this->_impl_.time_->MergeFrom(*from._impl_.time_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.spaces_ != nullptr);
      if (_this->_impl_.spaces_ == nullptr) {
        _this->_impl_.spaces_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpParkingSpaces>(arena, *from._impl_.spaces_);
      } else {
        _this->_impl_.spaces_->MergeFrom(*from._impl_.spaces_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpCCTVMonitoringData::CopyFrom(const AvpCCTVMonitoringData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpCCTVMonitoringData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpCCTVMonitoringData::InternalSwap(AvpCCTVMonitoringData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.avp_cars_.InternalSwap(&other->_impl_.avp_cars_);
  _impl_.cars_.InternalSwap(&other->_impl_.cars_);
  _impl_.persons_.InternalSwap(&other->_impl_.persons_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.spaces_)
      + sizeof(AvpCCTVMonitoringData::_impl_.spaces_)
      - PROTOBUF_FIELD_OFFSET(AvpCCTVMonitoringData, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::google::protobuf::Metadata AvpCCTVMonitoringData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleParkingSensor::_Internal {
 public:
};

AvpVehicleParkingSensor::AvpVehicleParkingSensor(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleParkingSensor)
}
AvpVehicleParkingSensor::AvpVehicleParkingSensor(
    ::google::protobuf::Arena* arena, const AvpVehicleParkingSensor& from)
    : AvpVehicleParkingSensor(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleParkingSensor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehicleParkingSensor::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, fr_alarm_),
           0,
           offsetof(Impl_, ror_ind_) -
               offsetof(Impl_, fr_alarm_) +
               sizeof(Impl_::ror_ind_));
}
AvpVehicleParkingSensor::~AvpVehicleParkingSensor() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleParkingSensor)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleParkingSensor::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleParkingSensor::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleParkingSensor_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleParkingSensor::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleParkingSensor>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleParkingSensor>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleParkingSensor>(), &AvpVehicleParkingSensor::ByteSizeLong,
                &AvpVehicleParkingSensor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_._cached_size_),
            false,
        },
        &AvpVehicleParkingSensor::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleParkingSensor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 14, 0, 0, 2> AvpVehicleParkingSensor::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    14, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294950912,  // skipmap
    offsetof(decltype(_table_), field_entries),
    14,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleParkingSensor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // uint32 FR_alarm = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.fr_alarm_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fr_alarm_)}},
    // uint32 FCS_alarm = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.fcs_alarm_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fcs_alarm_)}},
    // uint32 FLS_alarm = 3;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.fls_alarm_), 63>(),
     {24, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fls_alarm_)}},
    // uint32 FRS_alarm = 4;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.frs_alarm_), 63>(),
     {32, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.frs_alarm_)}},
    // uint32 FI_ind = 5;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.fi_ind_), 63>(),
     {40, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fi_ind_)}},
    // uint32 FOL_ind = 6;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.fol_ind_), 63>(),
     {48, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fol_ind_)}},
    // uint32 FOR_ind = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.for_ind_), 63>(),
     {56, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.for_ind_)}},
    // uint32 RR_alarm = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.rr_alarm_), 63>(),
     {64, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rr_alarm_)}},
    // uint32 RCS_alarm = 9;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.rcs_alarm_), 63>(),
     {72, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rcs_alarm_)}},
    // uint32 RLS_alarm = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.rls_alarm_), 63>(),
     {80, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rls_alarm_)}},
    // uint32 RRS_alarm = 11;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.rrs_alarm_), 63>(),
     {88, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rrs_alarm_)}},
    // uint32 RI_ind = 12;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.ri_ind_), 63>(),
     {96, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.ri_ind_)}},
    // uint32 ROL_ind = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.rol_ind_), 63>(),
     {104, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rol_ind_)}},
    // uint32 ROR_ind = 14;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleParkingSensor, _impl_.ror_ind_), 63>(),
     {112, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.ror_ind_)}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // uint32 FR_alarm = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fr_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FCS_alarm = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fcs_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FLS_alarm = 3;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fls_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FRS_alarm = 4;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.frs_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FI_ind = 5;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fi_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FOL_ind = 6;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fol_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 FOR_ind = 7;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.for_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 RR_alarm = 8;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rr_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 RCS_alarm = 9;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rcs_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 RLS_alarm = 10;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rls_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 RRS_alarm = 11;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rrs_alarm_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 RI_ind = 12;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.ri_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 ROL_ind = 13;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.rol_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
    // uint32 ROR_ind = 14;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.ror_ind_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleParkingSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleParkingSensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.fr_alarm_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.ror_ind_) -
      reinterpret_cast<char*>(&_impl_.fr_alarm_)) + sizeof(_impl_.ror_ind_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleParkingSensor::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleParkingSensor& this_ = static_cast<const AvpVehicleParkingSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleParkingSensor::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleParkingSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleParkingSensor)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // uint32 FR_alarm = 1;
          if (this_._internal_fr_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                1, this_._internal_fr_alarm(), target);
          }

          // uint32 FCS_alarm = 2;
          if (this_._internal_fcs_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                2, this_._internal_fcs_alarm(), target);
          }

          // uint32 FLS_alarm = 3;
          if (this_._internal_fls_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                3, this_._internal_fls_alarm(), target);
          }

          // uint32 FRS_alarm = 4;
          if (this_._internal_frs_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                4, this_._internal_frs_alarm(), target);
          }

          // uint32 FI_ind = 5;
          if (this_._internal_fi_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                5, this_._internal_fi_ind(), target);
          }

          // uint32 FOL_ind = 6;
          if (this_._internal_fol_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                6, this_._internal_fol_ind(), target);
          }

          // uint32 FOR_ind = 7;
          if (this_._internal_for_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                7, this_._internal_for_ind(), target);
          }

          // uint32 RR_alarm = 8;
          if (this_._internal_rr_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                8, this_._internal_rr_alarm(), target);
          }

          // uint32 RCS_alarm = 9;
          if (this_._internal_rcs_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                9, this_._internal_rcs_alarm(), target);
          }

          // uint32 RLS_alarm = 10;
          if (this_._internal_rls_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                10, this_._internal_rls_alarm(), target);
          }

          // uint32 RRS_alarm = 11;
          if (this_._internal_rrs_alarm() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                11, this_._internal_rrs_alarm(), target);
          }

          // uint32 RI_ind = 12;
          if (this_._internal_ri_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                12, this_._internal_ri_ind(), target);
          }

          // uint32 ROL_ind = 13;
          if (this_._internal_rol_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                13, this_._internal_rol_ind(), target);
          }

          // uint32 ROR_ind = 14;
          if (this_._internal_ror_ind() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
                14, this_._internal_ror_ind(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleParkingSensor)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleParkingSensor::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleParkingSensor& this_ = static_cast<const AvpVehicleParkingSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleParkingSensor::ByteSizeLong() const {
          const AvpVehicleParkingSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleParkingSensor)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // uint32 FR_alarm = 1;
            if (this_._internal_fr_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_fr_alarm());
            }
            // uint32 FCS_alarm = 2;
            if (this_._internal_fcs_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_fcs_alarm());
            }
            // uint32 FLS_alarm = 3;
            if (this_._internal_fls_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_fls_alarm());
            }
            // uint32 FRS_alarm = 4;
            if (this_._internal_frs_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_frs_alarm());
            }
            // uint32 FI_ind = 5;
            if (this_._internal_fi_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_fi_ind());
            }
            // uint32 FOL_ind = 6;
            if (this_._internal_fol_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_fol_ind());
            }
            // uint32 FOR_ind = 7;
            if (this_._internal_for_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_for_ind());
            }
            // uint32 RR_alarm = 8;
            if (this_._internal_rr_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_rr_alarm());
            }
            // uint32 RCS_alarm = 9;
            if (this_._internal_rcs_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_rcs_alarm());
            }
            // uint32 RLS_alarm = 10;
            if (this_._internal_rls_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_rls_alarm());
            }
            // uint32 RRS_alarm = 11;
            if (this_._internal_rrs_alarm() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_rrs_alarm());
            }
            // uint32 RI_ind = 12;
            if (this_._internal_ri_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_ri_ind());
            }
            // uint32 ROL_ind = 13;
            if (this_._internal_rol_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_rol_ind());
            }
            // uint32 ROR_ind = 14;
            if (this_._internal_ror_ind() != 0) {
              total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
                  this_._internal_ror_ind());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleParkingSensor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleParkingSensor*>(&to_msg);
  auto& from = static_cast<const AvpVehicleParkingSensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleParkingSensor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_fr_alarm() != 0) {
    _this->_impl_.fr_alarm_ = from._impl_.fr_alarm_;
  }
  if (from._internal_fcs_alarm() != 0) {
    _this->_impl_.fcs_alarm_ = from._impl_.fcs_alarm_;
  }
  if (from._internal_fls_alarm() != 0) {
    _this->_impl_.fls_alarm_ = from._impl_.fls_alarm_;
  }
  if (from._internal_frs_alarm() != 0) {
    _this->_impl_.frs_alarm_ = from._impl_.frs_alarm_;
  }
  if (from._internal_fi_ind() != 0) {
    _this->_impl_.fi_ind_ = from._impl_.fi_ind_;
  }
  if (from._internal_fol_ind() != 0) {
    _this->_impl_.fol_ind_ = from._impl_.fol_ind_;
  }
  if (from._internal_for_ind() != 0) {
    _this->_impl_.for_ind_ = from._impl_.for_ind_;
  }
  if (from._internal_rr_alarm() != 0) {
    _this->_impl_.rr_alarm_ = from._impl_.rr_alarm_;
  }
  if (from._internal_rcs_alarm() != 0) {
    _this->_impl_.rcs_alarm_ = from._impl_.rcs_alarm_;
  }
  if (from._internal_rls_alarm() != 0) {
    _this->_impl_.rls_alarm_ = from._impl_.rls_alarm_;
  }
  if (from._internal_rrs_alarm() != 0) {
    _this->_impl_.rrs_alarm_ = from._impl_.rrs_alarm_;
  }
  if (from._internal_ri_ind() != 0) {
    _this->_impl_.ri_ind_ = from._impl_.ri_ind_;
  }
  if (from._internal_rol_ind() != 0) {
    _this->_impl_.rol_ind_ = from._impl_.rol_ind_;
  }
  if (from._internal_ror_ind() != 0) {
    _this->_impl_.ror_ind_ = from._impl_.ror_ind_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleParkingSensor::CopyFrom(const AvpVehicleParkingSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleParkingSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleParkingSensor::InternalSwap(AvpVehicleParkingSensor* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.ror_ind_)
      + sizeof(AvpVehicleParkingSensor::_impl_.ror_ind_)
      - PROTOBUF_FIELD_OFFSET(AvpVehicleParkingSensor, _impl_.fr_alarm_)>(
          reinterpret_cast<char*>(&_impl_.fr_alarm_),
          reinterpret_cast<char*>(&other->_impl_.fr_alarm_));
}

::google::protobuf::Metadata AvpVehicleParkingSensor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleSteeringSensor::_Internal {
 public:
};

AvpVehicleSteeringSensor::AvpVehicleSteeringSensor(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleSteeringSensor)
}
AvpVehicleSteeringSensor::AvpVehicleSteeringSensor(
    ::google::protobuf::Arena* arena, const AvpVehicleSteeringSensor& from)
    : AvpVehicleSteeringSensor(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleSteeringSensor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehicleSteeringSensor::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, sas_angle_),
           0,
           offsetof(Impl_, sas_speed_) -
               offsetof(Impl_, sas_angle_) +
               sizeof(Impl_::sas_speed_));
}
AvpVehicleSteeringSensor::~AvpVehicleSteeringSensor() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleSteeringSensor)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleSteeringSensor::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleSteeringSensor::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleSteeringSensor_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleSteeringSensor::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleSteeringSensor>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleSteeringSensor>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleSteeringSensor>(), &AvpVehicleSteeringSensor::ByteSizeLong,
                &AvpVehicleSteeringSensor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_._cached_size_),
            false,
        },
        &AvpVehicleSteeringSensor::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleSteeringSensor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AvpVehicleSteeringSensor::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleSteeringSensor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // double sas_speed = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_speed_)}},
    // double sas_angle = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_angle_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double sas_angle = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_angle_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double sas_speed = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_speed_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleSteeringSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleSteeringSensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.sas_angle_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.sas_speed_) -
      reinterpret_cast<char*>(&_impl_.sas_angle_)) + sizeof(_impl_.sas_speed_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleSteeringSensor::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleSteeringSensor& this_ = static_cast<const AvpVehicleSteeringSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleSteeringSensor::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleSteeringSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleSteeringSensor)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // double sas_angle = 1;
          if (::absl::bit_cast<::uint64_t>(this_._internal_sas_angle()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_sas_angle(), target);
          }

          // double sas_speed = 2;
          if (::absl::bit_cast<::uint64_t>(this_._internal_sas_speed()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_sas_speed(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleSteeringSensor)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleSteeringSensor::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleSteeringSensor& this_ = static_cast<const AvpVehicleSteeringSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleSteeringSensor::ByteSizeLong() const {
          const AvpVehicleSteeringSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleSteeringSensor)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // double sas_angle = 1;
            if (::absl::bit_cast<::uint64_t>(this_._internal_sas_angle()) != 0) {
              total_size += 9;
            }
            // double sas_speed = 2;
            if (::absl::bit_cast<::uint64_t>(this_._internal_sas_speed()) != 0) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleSteeringSensor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleSteeringSensor*>(&to_msg);
  auto& from = static_cast<const AvpVehicleSteeringSensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleSteeringSensor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (::absl::bit_cast<::uint64_t>(from._internal_sas_angle()) != 0) {
    _this->_impl_.sas_angle_ = from._impl_.sas_angle_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_sas_speed()) != 0) {
    _this->_impl_.sas_speed_ = from._impl_.sas_speed_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleSteeringSensor::CopyFrom(const AvpVehicleSteeringSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleSteeringSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleSteeringSensor::InternalSwap(AvpVehicleSteeringSensor* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_speed_)
      + sizeof(AvpVehicleSteeringSensor::_impl_.sas_speed_)
      - PROTOBUF_FIELD_OFFSET(AvpVehicleSteeringSensor, _impl_.sas_angle_)>(
          reinterpret_cast<char*>(&_impl_.sas_angle_),
          reinterpret_cast<char*>(&other->_impl_.sas_angle_));
}

::google::protobuf::Metadata AvpVehicleSteeringSensor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleStabilitySensor::_Internal {
 public:
};

AvpVehicleStabilitySensor::AvpVehicleStabilitySensor(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleStabilitySensor)
}
AvpVehicleStabilitySensor::AvpVehicleStabilitySensor(
    ::google::protobuf::Arena* arena, const AvpVehicleStabilitySensor& from)
    : AvpVehicleStabilitySensor(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleStabilitySensor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehicleStabilitySensor::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, esp_lat_accel_),
           0,
           offsetof(Impl_, esp_yaw_rate_) -
               offsetof(Impl_, esp_lat_accel_) +
               sizeof(Impl_::esp_yaw_rate_));
}
AvpVehicleStabilitySensor::~AvpVehicleStabilitySensor() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleStabilitySensor)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleStabilitySensor::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleStabilitySensor::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleStabilitySensor_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleStabilitySensor::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleStabilitySensor>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleStabilitySensor>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleStabilitySensor>(), &AvpVehicleStabilitySensor::ByteSizeLong,
                &AvpVehicleStabilitySensor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_._cached_size_),
            false,
        },
        &AvpVehicleStabilitySensor::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleStabilitySensor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 3, 0, 0, 2> AvpVehicleStabilitySensor::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    3, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967288,  // skipmap
    offsetof(decltype(_table_), field_entries),
    3,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleStabilitySensor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // double esp_lat_accel = 1;
    {::_pbi::TcParser::FastF64S1,
     {9, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_lat_accel_)}},
    // double esp_long_accel = 2;
    {::_pbi::TcParser::FastF64S1,
     {17, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_long_accel_)}},
    // double esp_yaw_rate = 3;
    {::_pbi::TcParser::FastF64S1,
     {25, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_yaw_rate_)}},
  }}, {{
    65535, 65535
  }}, {{
    // double esp_lat_accel = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_lat_accel_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double esp_long_accel = 2;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_long_accel_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
    // double esp_yaw_rate = 3;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_yaw_rate_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kDouble)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleStabilitySensor::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleStabilitySensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.esp_lat_accel_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.esp_yaw_rate_) -
      reinterpret_cast<char*>(&_impl_.esp_lat_accel_)) + sizeof(_impl_.esp_yaw_rate_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleStabilitySensor::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleStabilitySensor& this_ = static_cast<const AvpVehicleStabilitySensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleStabilitySensor::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleStabilitySensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleStabilitySensor)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // double esp_lat_accel = 1;
          if (::absl::bit_cast<::uint64_t>(this_._internal_esp_lat_accel()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                1, this_._internal_esp_lat_accel(), target);
          }

          // double esp_long_accel = 2;
          if (::absl::bit_cast<::uint64_t>(this_._internal_esp_long_accel()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                2, this_._internal_esp_long_accel(), target);
          }

          // double esp_yaw_rate = 3;
          if (::absl::bit_cast<::uint64_t>(this_._internal_esp_yaw_rate()) != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteDoubleToArray(
                3, this_._internal_esp_yaw_rate(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleStabilitySensor)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleStabilitySensor::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleStabilitySensor& this_ = static_cast<const AvpVehicleStabilitySensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleStabilitySensor::ByteSizeLong() const {
          const AvpVehicleStabilitySensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleStabilitySensor)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // double esp_lat_accel = 1;
            if (::absl::bit_cast<::uint64_t>(this_._internal_esp_lat_accel()) != 0) {
              total_size += 9;
            }
            // double esp_long_accel = 2;
            if (::absl::bit_cast<::uint64_t>(this_._internal_esp_long_accel()) != 0) {
              total_size += 9;
            }
            // double esp_yaw_rate = 3;
            if (::absl::bit_cast<::uint64_t>(this_._internal_esp_yaw_rate()) != 0) {
              total_size += 9;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleStabilitySensor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleStabilitySensor*>(&to_msg);
  auto& from = static_cast<const AvpVehicleStabilitySensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleStabilitySensor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (::absl::bit_cast<::uint64_t>(from._internal_esp_lat_accel()) != 0) {
    _this->_impl_.esp_lat_accel_ = from._impl_.esp_lat_accel_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_esp_long_accel()) != 0) {
    _this->_impl_.esp_long_accel_ = from._impl_.esp_long_accel_;
  }
  if (::absl::bit_cast<::uint64_t>(from._internal_esp_yaw_rate()) != 0) {
    _this->_impl_.esp_yaw_rate_ = from._impl_.esp_yaw_rate_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleStabilitySensor::CopyFrom(const AvpVehicleStabilitySensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleStabilitySensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleStabilitySensor::InternalSwap(AvpVehicleStabilitySensor* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_yaw_rate_)
      + sizeof(AvpVehicleStabilitySensor::_impl_.esp_yaw_rate_)
      - PROTOBUF_FIELD_OFFSET(AvpVehicleStabilitySensor, _impl_.esp_lat_accel_)>(
          reinterpret_cast<char*>(&_impl_.esp_lat_accel_),
          reinterpret_cast<char*>(&other->_impl_.esp_lat_accel_));
}

::google::protobuf::Metadata AvpVehicleStabilitySensor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpVehicleDoorSensor::_Internal {
 public:
};

AvpVehicleDoorSensor::AvpVehicleDoorSensor(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpVehicleDoorSensor)
}
AvpVehicleDoorSensor::AvpVehicleDoorSensor(
    ::google::protobuf::Arena* arena, const AvpVehicleDoorSensor& from)
    : AvpVehicleDoorSensor(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpVehicleDoorSensor::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpVehicleDoorSensor::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.front_ = {};
}
AvpVehicleDoorSensor::~AvpVehicleDoorSensor() {
  // @@protoc_insertion_point(destructor:keti.AvpVehicleDoorSensor)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpVehicleDoorSensor::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpVehicleDoorSensor::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpVehicleDoorSensor_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpVehicleDoorSensor::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpVehicleDoorSensor>(),
            ::google::protobuf::Message::GetNewImpl<AvpVehicleDoorSensor>(),
            ::google::protobuf::Message::GetClearImpl<AvpVehicleDoorSensor>(), &AvpVehicleDoorSensor::ByteSizeLong,
                &AvpVehicleDoorSensor::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpVehicleDoorSensor, _impl_._cached_size_),
            false,
        },
        &AvpVehicleDoorSensor::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpVehicleDoorSensor::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> AvpVehicleDoorSensor::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpVehicleDoorSensor>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // int32 front = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpVehicleDoorSensor, _impl_.front_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(AvpVehicleDoorSensor, _impl_.front_)}},
  }}, {{
    65535, 65535
  }}, {{
    // int32 front = 1;
    {PROTOBUF_FIELD_OFFSET(AvpVehicleDoorSensor, _impl_.front_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kInt32)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpVehicleDoorSensor::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpVehicleDoorSensor)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.front_ = 0;
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpVehicleDoorSensor::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpVehicleDoorSensor& this_ = static_cast<const AvpVehicleDoorSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpVehicleDoorSensor::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpVehicleDoorSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpVehicleDoorSensor)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // int32 front = 1;
          if (this_._internal_front() != 0) {
            target = ::google::protobuf::internal::WireFormatLite::
                WriteInt32ToArrayWithField<1>(
                    stream, this_._internal_front(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpVehicleDoorSensor)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpVehicleDoorSensor::ByteSizeLong(const MessageLite& base) {
          const AvpVehicleDoorSensor& this_ = static_cast<const AvpVehicleDoorSensor&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpVehicleDoorSensor::ByteSizeLong() const {
          const AvpVehicleDoorSensor& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpVehicleDoorSensor)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // int32 front = 1;
            if (this_._internal_front() != 0) {
              total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
                  this_._internal_front());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpVehicleDoorSensor::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpVehicleDoorSensor*>(&to_msg);
  auto& from = static_cast<const AvpVehicleDoorSensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpVehicleDoorSensor)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_front() != 0) {
    _this->_impl_.front_ = from._impl_.front_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpVehicleDoorSensor::CopyFrom(const AvpVehicleDoorSensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpVehicleDoorSensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpVehicleDoorSensor::InternalSwap(AvpVehicleDoorSensor* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
        swap(_impl_.front_, other->_impl_.front_);
}

::google::protobuf::Metadata AvpVehicleDoorSensor::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpCANSensorData::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpCANSensorData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_._has_bits_);
};

void AvpCANSensorData::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ != nullptr) _impl_.time_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
AvpCANSensorData::AvpCANSensorData(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpCANSensorData)
}
inline PROTOBUF_NDEBUG_INLINE AvpCANSensorData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpCANSensorData& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

AvpCANSensorData::AvpCANSensorData(
    ::google::protobuf::Arena* arena,
    const AvpCANSensorData& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpCANSensorData* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.time_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(
                              arena, *from._impl_.time_)
                        : nullptr;
  _impl_.parking_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleParkingSensor>(
                              arena, *from._impl_.parking_)
                        : nullptr;
  _impl_.steering_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleSteeringSensor>(
                              arena, *from._impl_.steering_)
                        : nullptr;
  _impl_.stability_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleStabilitySensor>(
                              arena, *from._impl_.stability_)
                        : nullptr;
  _impl_.door_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleDoorSensor>(
                              arena, *from._impl_.door_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:keti.AvpCANSensorData)
}
inline PROTOBUF_NDEBUG_INLINE AvpCANSensorData::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpCANSensorData::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, time_),
           0,
           offsetof(Impl_, door_) -
               offsetof(Impl_, time_) +
               sizeof(Impl_::door_));
}
AvpCANSensorData::~AvpCANSensorData() {
  // @@protoc_insertion_point(destructor:keti.AvpCANSensorData)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpCANSensorData::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.time_;
  delete _impl_.parking_;
  delete _impl_.steering_;
  delete _impl_.stability_;
  delete _impl_.door_;
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpCANSensorData::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpCANSensorData_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpCANSensorData::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpCANSensorData>(),
            ::google::protobuf::Message::GetNewImpl<AvpCANSensorData>(),
            ::google::protobuf::Message::GetClearImpl<AvpCANSensorData>(), &AvpCANSensorData::ByteSizeLong,
                &AvpCANSensorData::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_._cached_size_),
            false,
        },
        &AvpCANSensorData::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpCANSensorData::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 5, 0, 2> AvpCANSensorData::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    5,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpCANSensorData>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .google.protobuf.Timestamp time = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.time_)}},
    // .keti.AvpVehicleParkingSensor parking = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.parking_)}},
    // .keti.AvpVehicleSteeringSensor steering = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.steering_)}},
    // .keti.AvpVehicleStabilitySensor stability = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.stability_)}},
    // .keti.AvpVehicleDoorSensor door = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 4, 4, PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.door_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .google.protobuf.Timestamp time = 1;
    {PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.time_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpVehicleParkingSensor parking = 2;
    {PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.parking_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpVehicleSteeringSensor steering = 3;
    {PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.steering_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpVehicleStabilitySensor stability = 4;
    {PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.stability_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpVehicleDoorSensor door = 5;
    {PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.door_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::google::protobuf::Timestamp>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicleParkingSensor>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicleSteeringSensor>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicleStabilitySensor>()},
    {::_pbi::TcParser::GetTable<::keti::AvpVehicleDoorSensor>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpCANSensorData::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpCANSensorData)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.time_ != nullptr);
      _impl_.time_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.parking_ != nullptr);
      _impl_.parking_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.steering_ != nullptr);
      _impl_.steering_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.stability_ != nullptr);
      _impl_.stability_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.door_ != nullptr);
      _impl_.door_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpCANSensorData::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpCANSensorData& this_ = static_cast<const AvpCANSensorData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpCANSensorData::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpCANSensorData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpCANSensorData)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .google.protobuf.Timestamp time = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.time_, this_._impl_.time_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpVehicleParkingSensor parking = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.parking_, this_._impl_.parking_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpVehicleSteeringSensor steering = 3;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.steering_, this_._impl_.steering_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpVehicleStabilitySensor stability = 4;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.stability_, this_._impl_.stability_->GetCachedSize(), target,
                stream);
          }

          // .keti.AvpVehicleDoorSensor door = 5;
          if (cached_has_bits & 0x00000010u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.door_, this_._impl_.door_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpCANSensorData)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpCANSensorData::ByteSizeLong(const MessageLite& base) {
          const AvpCANSensorData& this_ = static_cast<const AvpCANSensorData&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpCANSensorData::ByteSizeLong() const {
          const AvpCANSensorData& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpCANSensorData)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000001fu) {
            // .google.protobuf.Timestamp time = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.time_);
            }
            // .keti.AvpVehicleParkingSensor parking = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.parking_);
            }
            // .keti.AvpVehicleSteeringSensor steering = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.steering_);
            }
            // .keti.AvpVehicleStabilitySensor stability = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.stability_);
            }
            // .keti.AvpVehicleDoorSensor door = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.door_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpCANSensorData::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpCANSensorData*>(&to_msg);
  auto& from = static_cast<const AvpCANSensorData&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpCANSensorData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.time_ != nullptr);
      if (_this->_impl_.time_ == nullptr) {
        _this->_impl_.time_ =
            ::google::protobuf::Message::CopyConstruct<::google::protobuf::Timestamp>(arena, *from._impl_.time_);
      } else {
        _this->_impl_.time_->MergeFrom(*from._impl_.time_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.parking_ != nullptr);
      if (_this->_impl_.parking_ == nullptr) {
        _this->_impl_.parking_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleParkingSensor>(arena, *from._impl_.parking_);
      } else {
        _this->_impl_.parking_->MergeFrom(*from._impl_.parking_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.steering_ != nullptr);
      if (_this->_impl_.steering_ == nullptr) {
        _this->_impl_.steering_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleSteeringSensor>(arena, *from._impl_.steering_);
      } else {
        _this->_impl_.steering_->MergeFrom(*from._impl_.steering_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.stability_ != nullptr);
      if (_this->_impl_.stability_ == nullptr) {
        _this->_impl_.stability_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleStabilitySensor>(arena, *from._impl_.stability_);
      } else {
        _this->_impl_.stability_->MergeFrom(*from._impl_.stability_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.door_ != nullptr);
      if (_this->_impl_.door_ == nullptr) {
        _this->_impl_.door_ =
            ::google::protobuf::Message::CopyConstruct<::keti::AvpVehicleDoorSensor>(arena, *from._impl_.door_);
      } else {
        _this->_impl_.door_->MergeFrom(*from._impl_.door_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpCANSensorData::CopyFrom(const AvpCANSensorData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpCANSensorData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpCANSensorData::InternalSwap(AvpCANSensorData* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.door_)
      + sizeof(AvpCANSensorData::_impl_.door_)
      - PROTOBUF_FIELD_OFFSET(AvpCANSensorData, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::google::protobuf::Metadata AvpCANSensorData::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpControlMessage::_Internal {
 public:
};

AvpControlMessage::AvpControlMessage(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpControlMessage)
}
AvpControlMessage::AvpControlMessage(
    ::google::protobuf::Arena* arena, const AvpControlMessage& from)
    : AvpControlMessage(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE AvpControlMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void AvpControlMessage::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, type_),
           0,
           offsetof(Impl_, code_) -
               offsetof(Impl_, type_) +
               sizeof(Impl_::code_));
}
AvpControlMessage::~AvpControlMessage() {
  // @@protoc_insertion_point(destructor:keti.AvpControlMessage)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpControlMessage::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpControlMessage::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpControlMessage_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpControlMessage::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpControlMessage>(),
            ::google::protobuf::Message::GetNewImpl<AvpControlMessage>(),
            ::google::protobuf::Message::GetClearImpl<AvpControlMessage>(), &AvpControlMessage::ByteSizeLong,
                &AvpControlMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_._cached_size_),
            false,
        },
        &AvpControlMessage::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpControlMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> AvpControlMessage::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpControlMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .keti.AvpControlMessage.Code code = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpControlMessage, _impl_.code_), 63>(),
     {16, 63, 0, PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.code_)}},
    // .keti.AvpControlMessage.Type type = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(AvpControlMessage, _impl_.type_), 63>(),
     {8, 63, 0, PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.type_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .keti.AvpControlMessage.Type type = 1;
    {PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.type_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
    // .keti.AvpControlMessage.Code code = 2;
    {PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.code_), 0, 0,
    (0 | ::_fl::kFcSingular | ::_fl::kOpenEnum)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void AvpControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpControlMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.type_, 0, static_cast<::size_t>(
      reinterpret_cast<char*>(&_impl_.code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpControlMessage::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpControlMessage& this_ = static_cast<const AvpControlMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpControlMessage::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpControlMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpControlMessage)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // .keti.AvpControlMessage.Type type = 1;
          if (this_._internal_type() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                1, this_._internal_type(), target);
          }

          // .keti.AvpControlMessage.Code code = 2;
          if (this_._internal_code() != 0) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteEnumToArray(
                2, this_._internal_code(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpControlMessage)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpControlMessage::ByteSizeLong(const MessageLite& base) {
          const AvpControlMessage& this_ = static_cast<const AvpControlMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpControlMessage::ByteSizeLong() const {
          const AvpControlMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpControlMessage)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // .keti.AvpControlMessage.Type type = 1;
            if (this_._internal_type() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_type());
            }
            // .keti.AvpControlMessage.Code code = 2;
            if (this_._internal_code() != 0) {
              total_size += 1 +
                            ::_pbi::WireFormatLite::EnumSize(this_._internal_code());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpControlMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpControlMessage*>(&to_msg);
  auto& from = static_cast<const AvpControlMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpControlMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_type() != 0) {
    _this->_impl_.type_ = from._impl_.type_;
  }
  if (from._internal_code() != 0) {
    _this->_impl_.code_ = from._impl_.code_;
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpControlMessage::CopyFrom(const AvpControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpControlMessage::InternalSwap(AvpControlMessage* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.code_)
      + sizeof(AvpControlMessage::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(AvpControlMessage, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::google::protobuf::Metadata AvpControlMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpDataMessage::_Internal {
 public:
};

AvpDataMessage::AvpDataMessage(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpDataMessage)
}
inline PROTOBUF_NDEBUG_INLINE AvpDataMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpDataMessage& from_msg)
      : data_{visibility, arena, from.data_},
        _cached_size_{0} {}

AvpDataMessage::AvpDataMessage(
    ::google::protobuf::Arena* arena,
    const AvpDataMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpDataMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:keti.AvpDataMessage)
}
inline PROTOBUF_NDEBUG_INLINE AvpDataMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : data_{visibility, arena},
        _cached_size_{0} {}

inline void AvpDataMessage::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
AvpDataMessage::~AvpDataMessage() {
  // @@protoc_insertion_point(destructor:keti.AvpDataMessage)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpDataMessage::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  _impl_.~Impl_();
}

PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpDataMessage::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpDataMessage_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpDataMessage::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpDataMessage>(),
            ::google::protobuf::Message::GetNewImpl<AvpDataMessage>(),
            ::google::protobuf::Message::GetClearImpl<AvpDataMessage>(), &AvpDataMessage::ByteSizeLong,
                &AvpDataMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpDataMessage, _impl_._cached_size_),
            false,
        },
        &AvpDataMessage::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpDataMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> AvpDataMessage::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpDataMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .keti.AvpCANSensorData data = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(AvpDataMessage, _impl_.data_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .keti.AvpCANSensorData data = 1;
    {PROTOBUF_FIELD_OFFSET(AvpDataMessage, _impl_.data_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::AvpCANSensorData>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpDataMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpDataMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpDataMessage::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpDataMessage& this_ = static_cast<const AvpDataMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpDataMessage::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpDataMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpDataMessage)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .keti.AvpCANSensorData data = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_data_size());
               i < n; i++) {
            const auto& repfield = this_._internal_data().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpDataMessage)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpDataMessage::ByteSizeLong(const MessageLite& base) {
          const AvpDataMessage& this_ = static_cast<const AvpDataMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpDataMessage::ByteSizeLong() const {
          const AvpDataMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpDataMessage)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .keti.AvpCANSensorData data = 1;
             {
              total_size += 1UL * this_._internal_data_size();
              for (const auto& msg : this_._internal_data()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpDataMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpDataMessage*>(&to_msg);
  auto& from = static_cast<const AvpDataMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpDataMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_data()->MergeFrom(
      from._internal_data());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpDataMessage::CopyFrom(const AvpDataMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpDataMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpDataMessage::InternalSwap(AvpDataMessage* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
}

::google::protobuf::Metadata AvpDataMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AvpMessage::_Internal {
 public:
  using HasBits =
      decltype(std::declval<AvpMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::keti::AvpMessage, _impl_._oneof_case_);
};

void AvpMessage::set_allocated_ctrl(::keti::AvpControlMessage* ctrl) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_message();
  if (ctrl) {
    ::google::protobuf::Arena* submessage_arena = ctrl->GetArena();
    if (message_arena != submessage_arena) {
      ctrl = ::google::protobuf::internal::GetOwnedMessage(message_arena, ctrl, submessage_arena);
    }
    set_has_ctrl();
    _impl_.message_.ctrl_ = ctrl;
  }
  // @@protoc_insertion_point(field_set_allocated:keti.AvpMessage.ctrl)
}
void AvpMessage::set_allocated_data(::keti::AvpDataMessage* data) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_message();
  if (data) {
    ::google::protobuf::Arena* submessage_arena = data->GetArena();
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(message_arena, data, submessage_arena);
    }
    set_has_data();
    _impl_.message_.data_ = data;
  }
  // @@protoc_insertion_point(field_set_allocated:keti.AvpMessage.data)
}
AvpMessage::AvpMessage(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:keti.AvpMessage)
}
inline PROTOBUF_NDEBUG_INLINE AvpMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::keti::AvpMessage& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        message_{},
        _oneof_case_{from._oneof_case_[0]} {}

AvpMessage::AvpMessage(
    ::google::protobuf::Arena* arena,
    const AvpMessage& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AvpMessage* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.envelope_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::keti::Envelope>(
                              arena, *from._impl_.envelope_)
                        : nullptr;
  _impl_.id_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::keti::Ids>(
                              arena, *from._impl_.id_)
                        : nullptr;
  switch (message_case()) {
    case MESSAGE_NOT_SET:
      break;
      case kCtrl:
        _impl_.message_.ctrl_ = ::google::protobuf::Message::CopyConstruct<::keti::AvpControlMessage>(arena, *from._impl_.message_.ctrl_);
        break;
      case kData:
        _impl_.message_.data_ = ::google::protobuf::Message::CopyConstruct<::keti::AvpDataMessage>(arena, *from._impl_.message_.data_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:keti.AvpMessage)
}
inline PROTOBUF_NDEBUG_INLINE AvpMessage::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        message_{},
        _oneof_case_{} {}

inline void AvpMessage::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, envelope_),
           0,
           offsetof(Impl_, id_) -
               offsetof(Impl_, envelope_) +
               sizeof(Impl_::id_));
}
AvpMessage::~AvpMessage() {
  // @@protoc_insertion_point(destructor:keti.AvpMessage)
  _internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  SharedDtor();
}
inline void AvpMessage::SharedDtor() {
  ABSL_DCHECK(GetArena() == nullptr);
  delete _impl_.envelope_;
  delete _impl_.id_;
  if (has_message()) {
    clear_message();
  }
  _impl_.~Impl_();
}

void AvpMessage::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:keti.AvpMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (message_case()) {
    case kCtrl: {
      if (GetArena() == nullptr) {
        delete _impl_.message_.ctrl_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.ctrl_);
      }
      break;
    }
    case kData: {
      if (GetArena() == nullptr) {
        delete _impl_.message_.data_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.data_);
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}


PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::MessageLite::ClassDataFull
    AvpMessage::_class_data_ = {
        ::google::protobuf::Message::ClassData{
            &_AvpMessage_default_instance_._instance,
            &_table_.header,
            nullptr,  // OnDemandRegisterArenaDtor
            nullptr,  // IsInitialized
            &AvpMessage::MergeImpl,
#if defined(PROTOBUF_CUSTOM_VTABLE)
            ::google::protobuf::Message::GetDeleteImpl<AvpMessage>(),
            ::google::protobuf::Message::GetNewImpl<AvpMessage>(),
            ::google::protobuf::Message::GetClearImpl<AvpMessage>(), &AvpMessage::ByteSizeLong,
                &AvpMessage::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
            PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_._cached_size_),
            false,
        },
        &AvpMessage::kDescriptorMethods,
        &descriptor_table_Avp_2eproto,
        nullptr,  // tracker
};
const ::google::protobuf::MessageLite::ClassData* AvpMessage::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 4, 4, 0, 2> AvpMessage::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_._has_bits_),
    0, // no _extensions_
    4, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::keti::AvpMessage>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .keti.Ids id = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.id_)}},
    // .keti.Envelope envelope = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.envelope_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .keti.Envelope envelope = 1;
    {PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.envelope_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.Ids id = 2;
    {PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.id_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpControlMessage ctrl = 3;
    {PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.message_.ctrl_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .keti.AvpDataMessage data = 4;
    {PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.message_.data_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::keti::Envelope>()},
    {::_pbi::TcParser::GetTable<::keti::Ids>()},
    {::_pbi::TcParser::GetTable<::keti::AvpControlMessage>()},
    {::_pbi::TcParser::GetTable<::keti::AvpDataMessage>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void AvpMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:keti.AvpMessage)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.envelope_ != nullptr);
      _impl_.envelope_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.id_ != nullptr);
      _impl_.id_->Clear();
    }
  }
  clear_message();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* AvpMessage::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const AvpMessage& this_ = static_cast<const AvpMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* AvpMessage::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const AvpMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:keti.AvpMessage)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .keti.Envelope envelope = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.envelope_, this_._impl_.envelope_->GetCachedSize(), target,
                stream);
          }

          // .keti.Ids id = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.id_, this_._impl_.id_->GetCachedSize(), target,
                stream);
          }

          switch (this_.message_case()) {
            case kCtrl: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  3, *this_._impl_.message_.ctrl_, this_._impl_.message_.ctrl_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kData: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  4, *this_._impl_.message_.data_, this_._impl_.message_.data_->GetCachedSize(), target,
                  stream);
              break;
            }
            default:
              break;
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:keti.AvpMessage)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t AvpMessage::ByteSizeLong(const MessageLite& base) {
          const AvpMessage& this_ = static_cast<const AvpMessage&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t AvpMessage::ByteSizeLong() const {
          const AvpMessage& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:keti.AvpMessage)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // .keti.Envelope envelope = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.envelope_);
            }
            // .keti.Ids id = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.id_);
            }
          }
          switch (this_.message_case()) {
            // .keti.AvpControlMessage ctrl = 3;
            case kCtrl: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.message_.ctrl_);
              break;
            }
            // .keti.AvpDataMessage data = 4;
            case kData: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.message_.data_);
              break;
            }
            case MESSAGE_NOT_SET: {
              break;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void AvpMessage::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AvpMessage*>(&to_msg);
  auto& from = static_cast<const AvpMessage&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:keti.AvpMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.envelope_ != nullptr);
      if (_this->_impl_.envelope_ == nullptr) {
        _this->_impl_.envelope_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Envelope>(arena, *from._impl_.envelope_);
      } else {
        _this->_impl_.envelope_->MergeFrom(*from._impl_.envelope_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.id_ != nullptr);
      if (_this->_impl_.id_ == nullptr) {
        _this->_impl_.id_ =
            ::google::protobuf::Message::CopyConstruct<::keti::Ids>(arena, *from._impl_.id_);
      } else {
        _this->_impl_.id_->MergeFrom(*from._impl_.id_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_message();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kCtrl: {
        if (oneof_needs_init) {
          _this->_impl_.message_.ctrl_ =
              ::google::protobuf::Message::CopyConstruct<::keti::AvpControlMessage>(arena, *from._impl_.message_.ctrl_);
        } else {
          _this->_impl_.message_.ctrl_->MergeFrom(from._internal_ctrl());
        }
        break;
      }
      case kData: {
        if (oneof_needs_init) {
          _this->_impl_.message_.data_ =
              ::google::protobuf::Message::CopyConstruct<::keti::AvpDataMessage>(arena, *from._impl_.message_.data_);
        } else {
          _this->_impl_.message_.data_->MergeFrom(from._internal_data());
        }
        break;
      }
      case MESSAGE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AvpMessage::CopyFrom(const AvpMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:keti.AvpMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AvpMessage::InternalSwap(AvpMessage* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.id_)
      + sizeof(AvpMessage::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(AvpMessage, _impl_.envelope_)>(
          reinterpret_cast<char*>(&_impl_.envelope_),
          reinterpret_cast<char*>(&other->_impl_.envelope_));
  swap(_impl_.message_, other->_impl_.message_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata AvpMessage::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace keti
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_Avp_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
