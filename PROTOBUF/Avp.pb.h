// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: Avp.proto
// Protobuf C++ Version: 5.28.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_Avp_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_Avp_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_Avp_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_Avp_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_Avp_2eproto;
namespace keti {
class AvpCANSensorData;
struct AvpCANSensorDataDefaultTypeInternal;
extern AvpCANSensorDataDefaultTypeInternal _AvpCANSensorData_default_instance_;
class AvpCCTVMonitoringData;
struct AvpCCTVMonitoringDataDefaultTypeInternal;
extern AvpCCTVMonitoringDataDefaultTypeInternal _AvpCCTVMonitoringData_default_instance_;
class AvpControlMessage;
struct AvpControlMessageDefaultTypeInternal;
extern AvpControlMessageDefaultTypeInternal _AvpControlMessage_default_instance_;
class AvpDataMessage;
struct AvpDataMessageDefaultTypeInternal;
extern AvpDataMessageDefaultTypeInternal _AvpDataMessage_default_instance_;
class AvpGridPos;
struct AvpGridPosDefaultTypeInternal;
extern AvpGridPosDefaultTypeInternal _AvpGridPos_default_instance_;
class AvpMessage;
struct AvpMessageDefaultTypeInternal;
extern AvpMessageDefaultTypeInternal _AvpMessage_default_instance_;
class AvpParkingSpaces;
struct AvpParkingSpacesDefaultTypeInternal;
extern AvpParkingSpacesDefaultTypeInternal _AvpParkingSpaces_default_instance_;
class AvpVehicle;
struct AvpVehicleDefaultTypeInternal;
extern AvpVehicleDefaultTypeInternal _AvpVehicle_default_instance_;
class AvpVehicleAbnormalData;
struct AvpVehicleAbnormalDataDefaultTypeInternal;
extern AvpVehicleAbnormalDataDefaultTypeInternal _AvpVehicleAbnormalData_default_instance_;
class AvpVehicleAbnormalDataStream;
struct AvpVehicleAbnormalDataStreamDefaultTypeInternal;
extern AvpVehicleAbnormalDataStreamDefaultTypeInternal _AvpVehicleAbnormalDataStream_default_instance_;
class AvpVehicleDoorSensor;
struct AvpVehicleDoorSensorDefaultTypeInternal;
extern AvpVehicleDoorSensorDefaultTypeInternal _AvpVehicleDoorSensor_default_instance_;
class AvpVehicleParkingSensor;
struct AvpVehicleParkingSensorDefaultTypeInternal;
extern AvpVehicleParkingSensorDefaultTypeInternal _AvpVehicleParkingSensor_default_instance_;
class AvpVehiclePos;
struct AvpVehiclePosDefaultTypeInternal;
extern AvpVehiclePosDefaultTypeInternal _AvpVehiclePos_default_instance_;
class AvpVehicleStabilitySensor;
struct AvpVehicleStabilitySensorDefaultTypeInternal;
extern AvpVehicleStabilitySensorDefaultTypeInternal _AvpVehicleStabilitySensor_default_instance_;
class AvpVehicleSteeringSensor;
struct AvpVehicleSteeringSensorDefaultTypeInternal;
extern AvpVehicleSteeringSensorDefaultTypeInternal _AvpVehicleSteeringSensor_default_instance_;
class Entity;
struct EntityDefaultTypeInternal;
extern EntityDefaultTypeInternal _Entity_default_instance_;
class Envelope;
struct EnvelopeDefaultTypeInternal;
extern EnvelopeDefaultTypeInternal _Envelope_default_instance_;
class Ids;
struct IdsDefaultTypeInternal;
extern IdsDefaultTypeInternal _Ids_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace keti
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace keti {
enum AvpVehicleAbnormalData_AbnormalType : int {
  AvpVehicleAbnormalData_AbnormalType_UNKNOWN_TYPE = 0,
  AvpVehicleAbnormalData_AbnormalType_DRIVE_DIAGONAL = 1,
  AvpVehicleAbnormalData_AbnormalType_DRIVE_REVERSE = 2,
  AvpVehicleAbnormalData_AbnormalType_PARK_NON_PARK_AREA = 3,
  AvpVehicleAbnormalData_AbnormalType_PARK_STEP_ON_LINE = 4,
  AvpVehicleAbnormalData_AbnormalType_DRIVE_SPEED_LIMIT = 5,
  AvpVehicleAbnormalData_AbnormalType_DRIVE_DOOR_OPEN = 6,
  AvpVehicleAbnormalData_AbnormalType_IGNORE_ALARM = 7,
  AvpVehicleAbnormalData_AbnormalType_SUA = 8,
  AvpVehicleAbnormalData_AbnormalType_MEANDERING = 9,
  AvpVehicleAbnormalData_AbnormalType_COMM_ERROR = 10,
  AvpVehicleAbnormalData_AbnormalType_AvpVehicleAbnormalData_AbnormalType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AvpVehicleAbnormalData_AbnormalType_AvpVehicleAbnormalData_AbnormalType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AvpVehicleAbnormalData_AbnormalType_IsValid(int value);
extern const uint32_t AvpVehicleAbnormalData_AbnormalType_internal_data_[];
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData_AbnormalType_AbnormalType_MIN = static_cast<AvpVehicleAbnormalData_AbnormalType>(0);
constexpr AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData_AbnormalType_AbnormalType_MAX = static_cast<AvpVehicleAbnormalData_AbnormalType>(10);
constexpr int AvpVehicleAbnormalData_AbnormalType_AbnormalType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
AvpVehicleAbnormalData_AbnormalType_descriptor();
template <typename T>
const std::string& AvpVehicleAbnormalData_AbnormalType_Name(T value) {
  static_assert(std::is_same<T, AvpVehicleAbnormalData_AbnormalType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AbnormalType_Name().");
  return AvpVehicleAbnormalData_AbnormalType_Name(static_cast<AvpVehicleAbnormalData_AbnormalType>(value));
}
template <>
inline const std::string& AvpVehicleAbnormalData_AbnormalType_Name(AvpVehicleAbnormalData_AbnormalType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AvpVehicleAbnormalData_AbnormalType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool AvpVehicleAbnormalData_AbnormalType_Parse(absl::string_view name, AvpVehicleAbnormalData_AbnormalType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvpVehicleAbnormalData_AbnormalType>(
      AvpVehicleAbnormalData_AbnormalType_descriptor(), name, value);
}
enum AvpControlMessage_Type : int {
  AvpControlMessage_Type_UNKNOWN_TYPE = 0,
  AvpControlMessage_Type_REQ_RESET = 1,
  AvpControlMessage_Type_REQ_CONNECT = 2,
  AvpControlMessage_Type_RESP_CONNECT = 3,
  AvpControlMessage_Type_AvpControlMessage_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AvpControlMessage_Type_AvpControlMessage_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AvpControlMessage_Type_IsValid(int value);
extern const uint32_t AvpControlMessage_Type_internal_data_[];
constexpr AvpControlMessage_Type AvpControlMessage_Type_Type_MIN = static_cast<AvpControlMessage_Type>(0);
constexpr AvpControlMessage_Type AvpControlMessage_Type_Type_MAX = static_cast<AvpControlMessage_Type>(3);
constexpr int AvpControlMessage_Type_Type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AvpControlMessage_Type_descriptor();
template <typename T>
const std::string& AvpControlMessage_Type_Name(T value) {
  static_assert(std::is_same<T, AvpControlMessage_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return AvpControlMessage_Type_Name(static_cast<AvpControlMessage_Type>(value));
}
template <>
inline const std::string& AvpControlMessage_Type_Name(AvpControlMessage_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AvpControlMessage_Type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AvpControlMessage_Type_Parse(absl::string_view name, AvpControlMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvpControlMessage_Type>(
      AvpControlMessage_Type_descriptor(), name, value);
}
enum AvpControlMessage_Code : int {
  AvpControlMessage_Code_UNKNOWN_CODE = 0,
  AvpControlMessage_Code_SUCCESS = 1,
  AvpControlMessage_Code_FAIL = 2,
  AvpControlMessage_Code_AvpControlMessage_Code_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AvpControlMessage_Code_AvpControlMessage_Code_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AvpControlMessage_Code_IsValid(int value);
extern const uint32_t AvpControlMessage_Code_internal_data_[];
constexpr AvpControlMessage_Code AvpControlMessage_Code_Code_MIN = static_cast<AvpControlMessage_Code>(0);
constexpr AvpControlMessage_Code AvpControlMessage_Code_Code_MAX = static_cast<AvpControlMessage_Code>(2);
constexpr int AvpControlMessage_Code_Code_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
AvpControlMessage_Code_descriptor();
template <typename T>
const std::string& AvpControlMessage_Code_Name(T value) {
  static_assert(std::is_same<T, AvpControlMessage_Code>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Code_Name().");
  return AvpControlMessage_Code_Name(static_cast<AvpControlMessage_Code>(value));
}
template <>
inline const std::string& AvpControlMessage_Code_Name(AvpControlMessage_Code value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AvpControlMessage_Code_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool AvpControlMessage_Code_Parse(absl::string_view name, AvpControlMessage_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvpControlMessage_Code>(
      AvpControlMessage_Code_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Version final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Version(
      ::google::protobuf::internal::ConstantInitialized);

  inline Version(const Version& from) : Version(nullptr, from) {}
  inline Version(Version&& from) noexcept
      : Version(nullptr, std::move(from)) {}
  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
        &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Version& a, Version& b) { a.Swap(&b); }
  inline void Swap(Version* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Version>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Version& from) { Version::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Version* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.Version"; }

 protected:
  explicit Version(::google::protobuf::Arena* arena);
  Version(::google::protobuf::Arena* arena, const Version& from);
  Version(::google::protobuf::Arena* arena, Version&& from) noexcept
      : Version(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // uint32 major = 1;
  void clear_major() ;
  ::uint32_t major() const;
  void set_major(::uint32_t value);

  private:
  ::uint32_t _internal_major() const;
  void _internal_set_major(::uint32_t value);

  public:
  // uint32 minor = 2;
  void clear_minor() ;
  ::uint32_t minor() const;
  void set_minor(::uint32_t value);

  private:
  ::uint32_t _internal_minor() const;
  void _internal_set_minor(::uint32_t value);

  public:
  // uint32 patch = 3;
  void clear_patch() ;
  ::uint32_t patch() const;
  void set_patch(::uint32_t value);

  private:
  ::uint32_t _internal_patch() const;
  void _internal_set_patch(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:keti.Version)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Version_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Version& from_msg);
    ::uint32_t major_;
    ::uint32_t minor_;
    ::uint32_t patch_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class Ids final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.Ids) */ {
 public:
  inline Ids() : Ids(nullptr) {}
  ~Ids() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ids(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ids(const Ids& from) : Ids(nullptr, from) {}
  inline Ids(Ids&& from) noexcept
      : Ids(nullptr, std::move(from)) {}
  inline Ids& operator=(const Ids& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ids& operator=(Ids&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ids& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ids* internal_default_instance() {
    return reinterpret_cast<const Ids*>(
        &_Ids_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Ids& a, Ids& b) { a.Swap(&b); }
  inline void Swap(Ids* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ids* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ids* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Ids>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ids& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ids& from) { Ids::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ids* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.Ids"; }

 protected:
  explicit Ids(::google::protobuf::Arena* arena);
  Ids(::google::protobuf::Arena* arena, const Ids& from);
  Ids(::google::protobuf::Arena* arena, Ids&& from) noexcept
      : Ids(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kMessageIdFieldNumber = 2,
  };
  // string session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // int32 message_id = 2;
  void clear_message_id() ;
  ::int32_t message_id() const;
  void set_message_id(::int32_t value);

  private:
  ::int32_t _internal_message_id() const;
  void _internal_set_message_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:keti.Ids)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      27, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Ids_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ids& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::int32_t message_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleSteeringSensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleSteeringSensor) */ {
 public:
  inline AvpVehicleSteeringSensor() : AvpVehicleSteeringSensor(nullptr) {}
  ~AvpVehicleSteeringSensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleSteeringSensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleSteeringSensor(const AvpVehicleSteeringSensor& from) : AvpVehicleSteeringSensor(nullptr, from) {}
  inline AvpVehicleSteeringSensor(AvpVehicleSteeringSensor&& from) noexcept
      : AvpVehicleSteeringSensor(nullptr, std::move(from)) {}
  inline AvpVehicleSteeringSensor& operator=(const AvpVehicleSteeringSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleSteeringSensor& operator=(AvpVehicleSteeringSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleSteeringSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleSteeringSensor* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleSteeringSensor*>(
        &_AvpVehicleSteeringSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AvpVehicleSteeringSensor& a, AvpVehicleSteeringSensor& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleSteeringSensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleSteeringSensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleSteeringSensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleSteeringSensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleSteeringSensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleSteeringSensor& from) { AvpVehicleSteeringSensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleSteeringSensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleSteeringSensor"; }

 protected:
  explicit AvpVehicleSteeringSensor(::google::protobuf::Arena* arena);
  AvpVehicleSteeringSensor(::google::protobuf::Arena* arena, const AvpVehicleSteeringSensor& from);
  AvpVehicleSteeringSensor(::google::protobuf::Arena* arena, AvpVehicleSteeringSensor&& from) noexcept
      : AvpVehicleSteeringSensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSasAngleFieldNumber = 1,
    kSasSpeedFieldNumber = 2,
  };
  // double sas_angle = 1;
  void clear_sas_angle() ;
  double sas_angle() const;
  void set_sas_angle(double value);

  private:
  double _internal_sas_angle() const;
  void _internal_set_sas_angle(double value);

  public:
  // double sas_speed = 2;
  void clear_sas_speed() ;
  double sas_speed() const;
  void set_sas_speed(double value);

  private:
  double _internal_sas_speed() const;
  void _internal_set_sas_speed(double value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleSteeringSensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleSteeringSensor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleSteeringSensor& from_msg);
    double sas_angle_;
    double sas_speed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleStabilitySensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleStabilitySensor) */ {
 public:
  inline AvpVehicleStabilitySensor() : AvpVehicleStabilitySensor(nullptr) {}
  ~AvpVehicleStabilitySensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleStabilitySensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleStabilitySensor(const AvpVehicleStabilitySensor& from) : AvpVehicleStabilitySensor(nullptr, from) {}
  inline AvpVehicleStabilitySensor(AvpVehicleStabilitySensor&& from) noexcept
      : AvpVehicleStabilitySensor(nullptr, std::move(from)) {}
  inline AvpVehicleStabilitySensor& operator=(const AvpVehicleStabilitySensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleStabilitySensor& operator=(AvpVehicleStabilitySensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleStabilitySensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleStabilitySensor* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleStabilitySensor*>(
        &_AvpVehicleStabilitySensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(AvpVehicleStabilitySensor& a, AvpVehicleStabilitySensor& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleStabilitySensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleStabilitySensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleStabilitySensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleStabilitySensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleStabilitySensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleStabilitySensor& from) { AvpVehicleStabilitySensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleStabilitySensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleStabilitySensor"; }

 protected:
  explicit AvpVehicleStabilitySensor(::google::protobuf::Arena* arena);
  AvpVehicleStabilitySensor(::google::protobuf::Arena* arena, const AvpVehicleStabilitySensor& from);
  AvpVehicleStabilitySensor(::google::protobuf::Arena* arena, AvpVehicleStabilitySensor&& from) noexcept
      : AvpVehicleStabilitySensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEspLatAccelFieldNumber = 1,
    kEspLongAccelFieldNumber = 2,
    kEspYawRateFieldNumber = 3,
  };
  // double esp_lat_accel = 1;
  void clear_esp_lat_accel() ;
  double esp_lat_accel() const;
  void set_esp_lat_accel(double value);

  private:
  double _internal_esp_lat_accel() const;
  void _internal_set_esp_lat_accel(double value);

  public:
  // double esp_long_accel = 2;
  void clear_esp_long_accel() ;
  double esp_long_accel() const;
  void set_esp_long_accel(double value);

  private:
  double _internal_esp_long_accel() const;
  void _internal_set_esp_long_accel(double value);

  public:
  // double esp_yaw_rate = 3;
  void clear_esp_yaw_rate() ;
  double esp_yaw_rate() const;
  void set_esp_yaw_rate(double value);

  private:
  double _internal_esp_yaw_rate() const;
  void _internal_set_esp_yaw_rate(double value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleStabilitySensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleStabilitySensor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleStabilitySensor& from_msg);
    double esp_lat_accel_;
    double esp_long_accel_;
    double esp_yaw_rate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleParkingSensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleParkingSensor) */ {
 public:
  inline AvpVehicleParkingSensor() : AvpVehicleParkingSensor(nullptr) {}
  ~AvpVehicleParkingSensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleParkingSensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleParkingSensor(const AvpVehicleParkingSensor& from) : AvpVehicleParkingSensor(nullptr, from) {}
  inline AvpVehicleParkingSensor(AvpVehicleParkingSensor&& from) noexcept
      : AvpVehicleParkingSensor(nullptr, std::move(from)) {}
  inline AvpVehicleParkingSensor& operator=(const AvpVehicleParkingSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleParkingSensor& operator=(AvpVehicleParkingSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleParkingSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleParkingSensor* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleParkingSensor*>(
        &_AvpVehicleParkingSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AvpVehicleParkingSensor& a, AvpVehicleParkingSensor& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleParkingSensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleParkingSensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleParkingSensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleParkingSensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleParkingSensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleParkingSensor& from) { AvpVehicleParkingSensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleParkingSensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleParkingSensor"; }

 protected:
  explicit AvpVehicleParkingSensor(::google::protobuf::Arena* arena);
  AvpVehicleParkingSensor(::google::protobuf::Arena* arena, const AvpVehicleParkingSensor& from);
  AvpVehicleParkingSensor(::google::protobuf::Arena* arena, AvpVehicleParkingSensor&& from) noexcept
      : AvpVehicleParkingSensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFRAlarmFieldNumber = 1,
    kFCSAlarmFieldNumber = 2,
    kFLSAlarmFieldNumber = 3,
    kFRSAlarmFieldNumber = 4,
    kFIIndFieldNumber = 5,
    kFOLIndFieldNumber = 6,
    kFORIndFieldNumber = 7,
    kRRAlarmFieldNumber = 8,
    kRCSAlarmFieldNumber = 9,
    kRLSAlarmFieldNumber = 10,
    kRRSAlarmFieldNumber = 11,
    kRIIndFieldNumber = 12,
    kROLIndFieldNumber = 13,
    kRORIndFieldNumber = 14,
  };
  // uint32 FR_alarm = 1;
  void clear_fr_alarm() ;
  ::uint32_t fr_alarm() const;
  void set_fr_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_fr_alarm() const;
  void _internal_set_fr_alarm(::uint32_t value);

  public:
  // uint32 FCS_alarm = 2;
  void clear_fcs_alarm() ;
  ::uint32_t fcs_alarm() const;
  void set_fcs_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_fcs_alarm() const;
  void _internal_set_fcs_alarm(::uint32_t value);

  public:
  // uint32 FLS_alarm = 3;
  void clear_fls_alarm() ;
  ::uint32_t fls_alarm() const;
  void set_fls_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_fls_alarm() const;
  void _internal_set_fls_alarm(::uint32_t value);

  public:
  // uint32 FRS_alarm = 4;
  void clear_frs_alarm() ;
  ::uint32_t frs_alarm() const;
  void set_frs_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_frs_alarm() const;
  void _internal_set_frs_alarm(::uint32_t value);

  public:
  // uint32 FI_ind = 5;
  void clear_fi_ind() ;
  ::uint32_t fi_ind() const;
  void set_fi_ind(::uint32_t value);

  private:
  ::uint32_t _internal_fi_ind() const;
  void _internal_set_fi_ind(::uint32_t value);

  public:
  // uint32 FOL_ind = 6;
  void clear_fol_ind() ;
  ::uint32_t fol_ind() const;
  void set_fol_ind(::uint32_t value);

  private:
  ::uint32_t _internal_fol_ind() const;
  void _internal_set_fol_ind(::uint32_t value);

  public:
  // uint32 FOR_ind = 7;
  void clear_for_ind() ;
  ::uint32_t for_ind() const;
  void set_for_ind(::uint32_t value);

  private:
  ::uint32_t _internal_for_ind() const;
  void _internal_set_for_ind(::uint32_t value);

  public:
  // uint32 RR_alarm = 8;
  void clear_rr_alarm() ;
  ::uint32_t rr_alarm() const;
  void set_rr_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_rr_alarm() const;
  void _internal_set_rr_alarm(::uint32_t value);

  public:
  // uint32 RCS_alarm = 9;
  void clear_rcs_alarm() ;
  ::uint32_t rcs_alarm() const;
  void set_rcs_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_rcs_alarm() const;
  void _internal_set_rcs_alarm(::uint32_t value);

  public:
  // uint32 RLS_alarm = 10;
  void clear_rls_alarm() ;
  ::uint32_t rls_alarm() const;
  void set_rls_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_rls_alarm() const;
  void _internal_set_rls_alarm(::uint32_t value);

  public:
  // uint32 RRS_alarm = 11;
  void clear_rrs_alarm() ;
  ::uint32_t rrs_alarm() const;
  void set_rrs_alarm(::uint32_t value);

  private:
  ::uint32_t _internal_rrs_alarm() const;
  void _internal_set_rrs_alarm(::uint32_t value);

  public:
  // uint32 RI_ind = 12;
  void clear_ri_ind() ;
  ::uint32_t ri_ind() const;
  void set_ri_ind(::uint32_t value);

  private:
  ::uint32_t _internal_ri_ind() const;
  void _internal_set_ri_ind(::uint32_t value);

  public:
  // uint32 ROL_ind = 13;
  void clear_rol_ind() ;
  ::uint32_t rol_ind() const;
  void set_rol_ind(::uint32_t value);

  private:
  ::uint32_t _internal_rol_ind() const;
  void _internal_set_rol_ind(::uint32_t value);

  public:
  // uint32 ROR_ind = 14;
  void clear_ror_ind() ;
  ::uint32_t ror_ind() const;
  void set_ror_ind(::uint32_t value);

  private:
  ::uint32_t _internal_ror_ind() const;
  void _internal_set_ror_ind(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleParkingSensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleParkingSensor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleParkingSensor& from_msg);
    ::uint32_t fr_alarm_;
    ::uint32_t fcs_alarm_;
    ::uint32_t fls_alarm_;
    ::uint32_t frs_alarm_;
    ::uint32_t fi_ind_;
    ::uint32_t fol_ind_;
    ::uint32_t for_ind_;
    ::uint32_t rr_alarm_;
    ::uint32_t rcs_alarm_;
    ::uint32_t rls_alarm_;
    ::uint32_t rrs_alarm_;
    ::uint32_t ri_ind_;
    ::uint32_t rol_ind_;
    ::uint32_t ror_ind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleDoorSensor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleDoorSensor) */ {
 public:
  inline AvpVehicleDoorSensor() : AvpVehicleDoorSensor(nullptr) {}
  ~AvpVehicleDoorSensor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleDoorSensor(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleDoorSensor(const AvpVehicleDoorSensor& from) : AvpVehicleDoorSensor(nullptr, from) {}
  inline AvpVehicleDoorSensor(AvpVehicleDoorSensor&& from) noexcept
      : AvpVehicleDoorSensor(nullptr, std::move(from)) {}
  inline AvpVehicleDoorSensor& operator=(const AvpVehicleDoorSensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleDoorSensor& operator=(AvpVehicleDoorSensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleDoorSensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleDoorSensor* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleDoorSensor*>(
        &_AvpVehicleDoorSensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(AvpVehicleDoorSensor& a, AvpVehicleDoorSensor& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleDoorSensor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleDoorSensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleDoorSensor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleDoorSensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleDoorSensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleDoorSensor& from) { AvpVehicleDoorSensor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleDoorSensor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleDoorSensor"; }

 protected:
  explicit AvpVehicleDoorSensor(::google::protobuf::Arena* arena);
  AvpVehicleDoorSensor(::google::protobuf::Arena* arena, const AvpVehicleDoorSensor& from);
  AvpVehicleDoorSensor(::google::protobuf::Arena* arena, AvpVehicleDoorSensor&& from) noexcept
      : AvpVehicleDoorSensor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFrontFieldNumber = 1,
  };
  // int32 front = 1;
  void clear_front() ;
  ::int32_t front() const;
  void set_front(::int32_t value);

  private:
  ::int32_t _internal_front() const;
  void _internal_set_front(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleDoorSensor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleDoorSensor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleDoorSensor& from_msg);
    ::int32_t front_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpParkingSpaces final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpParkingSpaces) */ {
 public:
  inline AvpParkingSpaces() : AvpParkingSpaces(nullptr) {}
  ~AvpParkingSpaces() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpParkingSpaces(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpParkingSpaces(const AvpParkingSpaces& from) : AvpParkingSpaces(nullptr, from) {}
  inline AvpParkingSpaces(AvpParkingSpaces&& from) noexcept
      : AvpParkingSpaces(nullptr, std::move(from)) {}
  inline AvpParkingSpaces& operator=(const AvpParkingSpaces& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpParkingSpaces& operator=(AvpParkingSpaces&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpParkingSpaces& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpParkingSpaces* internal_default_instance() {
    return reinterpret_cast<const AvpParkingSpaces*>(
        &_AvpParkingSpaces_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AvpParkingSpaces& a, AvpParkingSpaces& b) { a.Swap(&b); }
  inline void Swap(AvpParkingSpaces* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpParkingSpaces* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpParkingSpaces* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpParkingSpaces>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpParkingSpaces& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpParkingSpaces& from) { AvpParkingSpaces::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpParkingSpaces* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpParkingSpaces"; }

 protected:
  explicit AvpParkingSpaces(::google::protobuf::Arena* arena);
  AvpParkingSpaces(::google::protobuf::Arena* arena, const AvpParkingSpaces& from);
  AvpParkingSpaces(::google::protobuf::Arena* arena, AvpParkingSpaces&& from) noexcept
      : AvpParkingSpaces(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kParkedFieldNumber = 1,
  };
  // repeated bool parked = 1;
  int parked_size() const;
  private:
  int _internal_parked_size() const;

  public:
  void clear_parked() ;
  bool parked(int index) const;
  void set_parked(int index, bool value);
  void add_parked(bool value);
  const ::google::protobuf::RepeatedField<bool>& parked() const;
  ::google::protobuf::RepeatedField<bool>* mutable_parked();

  private:
  const ::google::protobuf::RepeatedField<bool>& _internal_parked() const;
  ::google::protobuf::RepeatedField<bool>* _internal_mutable_parked();

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpParkingSpaces)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpParkingSpaces_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpParkingSpaces& from_msg);
    ::google::protobuf::RepeatedField<bool> parked_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpGridPos final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpGridPos) */ {
 public:
  inline AvpGridPos() : AvpGridPos(nullptr) {}
  ~AvpGridPos() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpGridPos(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpGridPos(const AvpGridPos& from) : AvpGridPos(nullptr, from) {}
  inline AvpGridPos(AvpGridPos&& from) noexcept
      : AvpGridPos(nullptr, std::move(from)) {}
  inline AvpGridPos& operator=(const AvpGridPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpGridPos& operator=(AvpGridPos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpGridPos& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpGridPos* internal_default_instance() {
    return reinterpret_cast<const AvpGridPos*>(
        &_AvpGridPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AvpGridPos& a, AvpGridPos& b) { a.Swap(&b); }
  inline void Swap(AvpGridPos* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpGridPos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpGridPos* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpGridPos>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpGridPos& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpGridPos& from) { AvpGridPos::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpGridPos* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpGridPos"; }

 protected:
  explicit AvpGridPos(::google::protobuf::Arena* arena);
  AvpGridPos(::google::protobuf::Arena* arena, const AvpGridPos& from);
  AvpGridPos(::google::protobuf::Arena* arena, AvpGridPos&& from) noexcept
      : AvpGridPos(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // int32 x = 1;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // int32 y = 2;
  void clear_y() ;
  ::int32_t y() const;
  void set_y(::int32_t value);

  private:
  ::int32_t _internal_y() const;
  void _internal_set_y(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpGridPos)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpGridPos_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpGridPos& from_msg);
    ::int32_t x_;
    ::int32_t y_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpControlMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpControlMessage) */ {
 public:
  inline AvpControlMessage() : AvpControlMessage(nullptr) {}
  ~AvpControlMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpControlMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpControlMessage(const AvpControlMessage& from) : AvpControlMessage(nullptr, from) {}
  inline AvpControlMessage(AvpControlMessage&& from) noexcept
      : AvpControlMessage(nullptr, std::move(from)) {}
  inline AvpControlMessage& operator=(const AvpControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpControlMessage& operator=(AvpControlMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpControlMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpControlMessage* internal_default_instance() {
    return reinterpret_cast<const AvpControlMessage*>(
        &_AvpControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(AvpControlMessage& a, AvpControlMessage& b) { a.Swap(&b); }
  inline void Swap(AvpControlMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpControlMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpControlMessage* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpControlMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpControlMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpControlMessage& from) { AvpControlMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpControlMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpControlMessage"; }

 protected:
  explicit AvpControlMessage(::google::protobuf::Arena* arena);
  AvpControlMessage(::google::protobuf::Arena* arena, const AvpControlMessage& from);
  AvpControlMessage(::google::protobuf::Arena* arena, AvpControlMessage&& from) noexcept
      : AvpControlMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = AvpControlMessage_Type;
  static constexpr Type UNKNOWN_TYPE = AvpControlMessage_Type_UNKNOWN_TYPE;
  static constexpr Type REQ_RESET = AvpControlMessage_Type_REQ_RESET;
  static constexpr Type REQ_CONNECT = AvpControlMessage_Type_REQ_CONNECT;
  static constexpr Type RESP_CONNECT = AvpControlMessage_Type_RESP_CONNECT;
  static inline bool Type_IsValid(int value) {
    return AvpControlMessage_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = AvpControlMessage_Type_Type_MIN;
  static constexpr Type Type_MAX = AvpControlMessage_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = AvpControlMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return AvpControlMessage_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return AvpControlMessage_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return AvpControlMessage_Type_Parse(name, value);
  }
  using Code = AvpControlMessage_Code;
  static constexpr Code UNKNOWN_CODE = AvpControlMessage_Code_UNKNOWN_CODE;
  static constexpr Code SUCCESS = AvpControlMessage_Code_SUCCESS;
  static constexpr Code FAIL = AvpControlMessage_Code_FAIL;
  static inline bool Code_IsValid(int value) {
    return AvpControlMessage_Code_IsValid(value);
  }
  static constexpr Code Code_MIN = AvpControlMessage_Code_Code_MIN;
  static constexpr Code Code_MAX = AvpControlMessage_Code_Code_MAX;
  static constexpr int Code_ARRAYSIZE = AvpControlMessage_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Code_descriptor() {
    return AvpControlMessage_Code_descriptor();
  }
  template <typename T>
  static inline const std::string& Code_Name(T value) {
    return AvpControlMessage_Code_Name(value);
  }
  static inline bool Code_Parse(absl::string_view name, Code* value) {
    return AvpControlMessage_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // .keti.AvpControlMessage.Type type = 1;
  void clear_type() ;
  ::keti::AvpControlMessage_Type type() const;
  void set_type(::keti::AvpControlMessage_Type value);

  private:
  ::keti::AvpControlMessage_Type _internal_type() const;
  void _internal_set_type(::keti::AvpControlMessage_Type value);

  public:
  // .keti.AvpControlMessage.Code code = 2;
  void clear_code() ;
  ::keti::AvpControlMessage_Code code() const;
  void set_code(::keti::AvpControlMessage_Code value);

  private:
  ::keti::AvpControlMessage_Code _internal_code() const;
  void _internal_set_code(::keti::AvpControlMessage_Code value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpControlMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpControlMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpControlMessage& from_msg);
    int type_;
    int code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class Entity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.Entity) */ {
 public:
  inline Entity() : Entity(nullptr) {}
  ~Entity() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Entity(
      ::google::protobuf::internal::ConstantInitialized);

  inline Entity(const Entity& from) : Entity(nullptr, from) {}
  inline Entity(Entity&& from) noexcept
      : Entity(nullptr, std::move(from)) {}
  inline Entity& operator=(const Entity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Entity& operator=(Entity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Entity& default_instance() {
    return *internal_default_instance();
  }
  static inline const Entity* internal_default_instance() {
    return reinterpret_cast<const Entity*>(
        &_Entity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Entity& a, Entity& b) { a.Swap(&b); }
  inline void Swap(Entity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Entity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Entity* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Entity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Entity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Entity& from) { Entity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Entity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.Entity"; }

 protected:
  explicit Entity(::google::protobuf::Arena* arena);
  Entity(::google::protobuf::Arena* arena, const Entity& from);
  Entity(::google::protobuf::Arena* arena, Entity&& from) noexcept
      : Entity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPrimaryIdFieldNumber = 1,
    kSecondaryIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kSoftwareVersionFieldNumber = 4,
    kHardwareVersionFieldNumber = 5,
  };
  // string primary_id = 1;
  void clear_primary_id() ;
  const std::string& primary_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_primary_id(Arg_&& arg, Args_... args);
  std::string* mutable_primary_id();
  PROTOBUF_NODISCARD std::string* release_primary_id();
  void set_allocated_primary_id(std::string* value);

  private:
  const std::string& _internal_primary_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_id(
      const std::string& value);
  std::string* _internal_mutable_primary_id();

  public:
  // string secondary_id = 2;
  void clear_secondary_id() ;
  const std::string& secondary_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secondary_id(Arg_&& arg, Args_... args);
  std::string* mutable_secondary_id();
  PROTOBUF_NODISCARD std::string* release_secondary_id();
  void set_allocated_secondary_id(std::string* value);

  private:
  const std::string& _internal_secondary_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secondary_id(
      const std::string& value);
  std::string* _internal_mutable_secondary_id();

  public:
  // string type = 3;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // .keti.Version software_version = 4;
  bool has_software_version() const;
  void clear_software_version() ;
  const ::keti::Version& software_version() const;
  PROTOBUF_NODISCARD ::keti::Version* release_software_version();
  ::keti::Version* mutable_software_version();
  void set_allocated_software_version(::keti::Version* value);
  void unsafe_arena_set_allocated_software_version(::keti::Version* value);
  ::keti::Version* unsafe_arena_release_software_version();

  private:
  const ::keti::Version& _internal_software_version() const;
  ::keti::Version* _internal_mutable_software_version();

  public:
  // .keti.Version hardware_version = 5;
  bool has_hardware_version() const;
  void clear_hardware_version() ;
  const ::keti::Version& hardware_version() const;
  PROTOBUF_NODISCARD ::keti::Version* release_hardware_version();
  ::keti::Version* mutable_hardware_version();
  void set_allocated_hardware_version(::keti::Version* value);
  void unsafe_arena_set_allocated_hardware_version(::keti::Version* value);
  ::keti::Version* unsafe_arena_release_hardware_version();

  private:
  const ::keti::Version& _internal_hardware_version() const;
  ::keti::Version* _internal_mutable_hardware_version();

  public:
  // @@protoc_insertion_point(class_scope:keti.Entity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Entity_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Entity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr primary_id_;
    ::google::protobuf::internal::ArenaStringPtr secondary_id_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    ::keti::Version* software_version_;
    ::keti::Version* hardware_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehiclePos final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehiclePos) */ {
 public:
  inline AvpVehiclePos() : AvpVehiclePos(nullptr) {}
  ~AvpVehiclePos() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehiclePos(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehiclePos(const AvpVehiclePos& from) : AvpVehiclePos(nullptr, from) {}
  inline AvpVehiclePos(AvpVehiclePos&& from) noexcept
      : AvpVehiclePos(nullptr, std::move(from)) {}
  inline AvpVehiclePos& operator=(const AvpVehiclePos& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehiclePos& operator=(AvpVehiclePos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehiclePos& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehiclePos* internal_default_instance() {
    return reinterpret_cast<const AvpVehiclePos*>(
        &_AvpVehiclePos_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AvpVehiclePos& a, AvpVehiclePos& b) { a.Swap(&b); }
  inline void Swap(AvpVehiclePos* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehiclePos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehiclePos* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehiclePos>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehiclePos& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehiclePos& from) { AvpVehiclePos::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehiclePos* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehiclePos"; }

 protected:
  explicit AvpVehiclePos(::google::protobuf::Arena* arena);
  AvpVehiclePos(::google::protobuf::Arena* arena, const AvpVehiclePos& from);
  AvpVehiclePos(::google::protobuf::Arena* arena, AvpVehiclePos&& from) noexcept
      : AvpVehiclePos(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPos1FieldNumber = 1,
    kPos2FieldNumber = 2,
  };
  // .keti.AvpGridPos pos1 = 1;
  bool has_pos1() const;
  void clear_pos1() ;
  const ::keti::AvpGridPos& pos1() const;
  PROTOBUF_NODISCARD ::keti::AvpGridPos* release_pos1();
  ::keti::AvpGridPos* mutable_pos1();
  void set_allocated_pos1(::keti::AvpGridPos* value);
  void unsafe_arena_set_allocated_pos1(::keti::AvpGridPos* value);
  ::keti::AvpGridPos* unsafe_arena_release_pos1();

  private:
  const ::keti::AvpGridPos& _internal_pos1() const;
  ::keti::AvpGridPos* _internal_mutable_pos1();

  public:
  // .keti.AvpGridPos pos2 = 2;
  bool has_pos2() const;
  void clear_pos2() ;
  const ::keti::AvpGridPos& pos2() const;
  PROTOBUF_NODISCARD ::keti::AvpGridPos* release_pos2();
  ::keti::AvpGridPos* mutable_pos2();
  void set_allocated_pos2(::keti::AvpGridPos* value);
  void unsafe_arena_set_allocated_pos2(::keti::AvpGridPos* value);
  ::keti::AvpGridPos* unsafe_arena_release_pos2();

  private:
  const ::keti::AvpGridPos& _internal_pos2() const;
  ::keti::AvpGridPos* _internal_mutable_pos2();

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehiclePos)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehiclePos_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehiclePos& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::keti::AvpGridPos* pos1_;
    ::keti::AvpGridPos* pos2_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleAbnormalData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleAbnormalData) */ {
 public:
  inline AvpVehicleAbnormalData() : AvpVehicleAbnormalData(nullptr) {}
  ~AvpVehicleAbnormalData() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleAbnormalData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleAbnormalData(const AvpVehicleAbnormalData& from) : AvpVehicleAbnormalData(nullptr, from) {}
  inline AvpVehicleAbnormalData(AvpVehicleAbnormalData&& from) noexcept
      : AvpVehicleAbnormalData(nullptr, std::move(from)) {}
  inline AvpVehicleAbnormalData& operator=(const AvpVehicleAbnormalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleAbnormalData& operator=(AvpVehicleAbnormalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleAbnormalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleAbnormalData* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleAbnormalData*>(
        &_AvpVehicleAbnormalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AvpVehicleAbnormalData& a, AvpVehicleAbnormalData& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleAbnormalData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleAbnormalData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleAbnormalData* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleAbnormalData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleAbnormalData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleAbnormalData& from) { AvpVehicleAbnormalData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleAbnormalData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleAbnormalData"; }

 protected:
  explicit AvpVehicleAbnormalData(::google::protobuf::Arena* arena);
  AvpVehicleAbnormalData(::google::protobuf::Arena* arena, const AvpVehicleAbnormalData& from);
  AvpVehicleAbnormalData(::google::protobuf::Arena* arena, AvpVehicleAbnormalData&& from) noexcept
      : AvpVehicleAbnormalData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using AbnormalType = AvpVehicleAbnormalData_AbnormalType;
  static constexpr AbnormalType UNKNOWN_TYPE = AvpVehicleAbnormalData_AbnormalType_UNKNOWN_TYPE;
  static constexpr AbnormalType DRIVE_DIAGONAL = AvpVehicleAbnormalData_AbnormalType_DRIVE_DIAGONAL;
  static constexpr AbnormalType DRIVE_REVERSE = AvpVehicleAbnormalData_AbnormalType_DRIVE_REVERSE;
  static constexpr AbnormalType PARK_NON_PARK_AREA = AvpVehicleAbnormalData_AbnormalType_PARK_NON_PARK_AREA;
  static constexpr AbnormalType PARK_STEP_ON_LINE = AvpVehicleAbnormalData_AbnormalType_PARK_STEP_ON_LINE;
  static constexpr AbnormalType DRIVE_SPEED_LIMIT = AvpVehicleAbnormalData_AbnormalType_DRIVE_SPEED_LIMIT;
  static constexpr AbnormalType DRIVE_DOOR_OPEN = AvpVehicleAbnormalData_AbnormalType_DRIVE_DOOR_OPEN;
  static constexpr AbnormalType IGNORE_ALARM = AvpVehicleAbnormalData_AbnormalType_IGNORE_ALARM;
  static constexpr AbnormalType SUA = AvpVehicleAbnormalData_AbnormalType_SUA;
  static constexpr AbnormalType MEANDERING = AvpVehicleAbnormalData_AbnormalType_MEANDERING;
  static constexpr AbnormalType COMM_ERROR = AvpVehicleAbnormalData_AbnormalType_COMM_ERROR;
  static inline bool AbnormalType_IsValid(int value) {
    return AvpVehicleAbnormalData_AbnormalType_IsValid(value);
  }
  static constexpr AbnormalType AbnormalType_MIN = AvpVehicleAbnormalData_AbnormalType_AbnormalType_MIN;
  static constexpr AbnormalType AbnormalType_MAX = AvpVehicleAbnormalData_AbnormalType_AbnormalType_MAX;
  static constexpr int AbnormalType_ARRAYSIZE = AvpVehicleAbnormalData_AbnormalType_AbnormalType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AbnormalType_descriptor() {
    return AvpVehicleAbnormalData_AbnormalType_descriptor();
  }
  template <typename T>
  static inline const std::string& AbnormalType_Name(T value) {
    return AvpVehicleAbnormalData_AbnormalType_Name(value);
  }
  static inline bool AbnormalType_Parse(absl::string_view name, AbnormalType* value) {
    return AvpVehicleAbnormalData_AbnormalType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
  void clear_type() ;
  ::keti::AvpVehicleAbnormalData_AbnormalType type() const;
  void set_type(::keti::AvpVehicleAbnormalData_AbnormalType value);

  private:
  ::keti::AvpVehicleAbnormalData_AbnormalType _internal_type() const;
  void _internal_set_type(::keti::AvpVehicleAbnormalData_AbnormalType value);

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleAbnormalData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleAbnormalData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleAbnormalData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* time_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpCANSensorData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpCANSensorData) */ {
 public:
  inline AvpCANSensorData() : AvpCANSensorData(nullptr) {}
  ~AvpCANSensorData() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpCANSensorData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpCANSensorData(const AvpCANSensorData& from) : AvpCANSensorData(nullptr, from) {}
  inline AvpCANSensorData(AvpCANSensorData&& from) noexcept
      : AvpCANSensorData(nullptr, std::move(from)) {}
  inline AvpCANSensorData& operator=(const AvpCANSensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpCANSensorData& operator=(AvpCANSensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpCANSensorData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpCANSensorData* internal_default_instance() {
    return reinterpret_cast<const AvpCANSensorData*>(
        &_AvpCANSensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AvpCANSensorData& a, AvpCANSensorData& b) { a.Swap(&b); }
  inline void Swap(AvpCANSensorData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpCANSensorData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpCANSensorData* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpCANSensorData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpCANSensorData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpCANSensorData& from) { AvpCANSensorData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpCANSensorData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpCANSensorData"; }

 protected:
  explicit AvpCANSensorData(::google::protobuf::Arena* arena);
  AvpCANSensorData(::google::protobuf::Arena* arena, const AvpCANSensorData& from);
  AvpCANSensorData(::google::protobuf::Arena* arena, AvpCANSensorData&& from) noexcept
      : AvpCANSensorData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 1,
    kParkingFieldNumber = 2,
    kSteeringFieldNumber = 3,
    kStabilityFieldNumber = 4,
    kDoorFieldNumber = 5,
  };
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .keti.AvpVehicleParkingSensor parking = 2;
  bool has_parking() const;
  void clear_parking() ;
  const ::keti::AvpVehicleParkingSensor& parking() const;
  PROTOBUF_NODISCARD ::keti::AvpVehicleParkingSensor* release_parking();
  ::keti::AvpVehicleParkingSensor* mutable_parking();
  void set_allocated_parking(::keti::AvpVehicleParkingSensor* value);
  void unsafe_arena_set_allocated_parking(::keti::AvpVehicleParkingSensor* value);
  ::keti::AvpVehicleParkingSensor* unsafe_arena_release_parking();

  private:
  const ::keti::AvpVehicleParkingSensor& _internal_parking() const;
  ::keti::AvpVehicleParkingSensor* _internal_mutable_parking();

  public:
  // .keti.AvpVehicleSteeringSensor steering = 3;
  bool has_steering() const;
  void clear_steering() ;
  const ::keti::AvpVehicleSteeringSensor& steering() const;
  PROTOBUF_NODISCARD ::keti::AvpVehicleSteeringSensor* release_steering();
  ::keti::AvpVehicleSteeringSensor* mutable_steering();
  void set_allocated_steering(::keti::AvpVehicleSteeringSensor* value);
  void unsafe_arena_set_allocated_steering(::keti::AvpVehicleSteeringSensor* value);
  ::keti::AvpVehicleSteeringSensor* unsafe_arena_release_steering();

  private:
  const ::keti::AvpVehicleSteeringSensor& _internal_steering() const;
  ::keti::AvpVehicleSteeringSensor* _internal_mutable_steering();

  public:
  // .keti.AvpVehicleStabilitySensor stability = 4;
  bool has_stability() const;
  void clear_stability() ;
  const ::keti::AvpVehicleStabilitySensor& stability() const;
  PROTOBUF_NODISCARD ::keti::AvpVehicleStabilitySensor* release_stability();
  ::keti::AvpVehicleStabilitySensor* mutable_stability();
  void set_allocated_stability(::keti::AvpVehicleStabilitySensor* value);
  void unsafe_arena_set_allocated_stability(::keti::AvpVehicleStabilitySensor* value);
  ::keti::AvpVehicleStabilitySensor* unsafe_arena_release_stability();

  private:
  const ::keti::AvpVehicleStabilitySensor& _internal_stability() const;
  ::keti::AvpVehicleStabilitySensor* _internal_mutable_stability();

  public:
  // .keti.AvpVehicleDoorSensor door = 5;
  bool has_door() const;
  void clear_door() ;
  const ::keti::AvpVehicleDoorSensor& door() const;
  PROTOBUF_NODISCARD ::keti::AvpVehicleDoorSensor* release_door();
  ::keti::AvpVehicleDoorSensor* mutable_door();
  void set_allocated_door(::keti::AvpVehicleDoorSensor* value);
  void unsafe_arena_set_allocated_door(::keti::AvpVehicleDoorSensor* value);
  ::keti::AvpVehicleDoorSensor* unsafe_arena_release_door();

  private:
  const ::keti::AvpVehicleDoorSensor& _internal_door() const;
  ::keti::AvpVehicleDoorSensor* _internal_mutable_door();

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpCANSensorData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpCANSensorData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpCANSensorData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::Timestamp* time_;
    ::keti::AvpVehicleParkingSensor* parking_;
    ::keti::AvpVehicleSteeringSensor* steering_;
    ::keti::AvpVehicleStabilitySensor* stability_;
    ::keti::AvpVehicleDoorSensor* door_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class Envelope final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.Envelope) */ {
 public:
  inline Envelope() : Envelope(nullptr) {}
  ~Envelope() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Envelope(
      ::google::protobuf::internal::ConstantInitialized);

  inline Envelope(const Envelope& from) : Envelope(nullptr, from) {}
  inline Envelope(Envelope&& from) noexcept
      : Envelope(nullptr, std::move(from)) {}
  inline Envelope& operator=(const Envelope& from) {
    CopyFrom(from);
    return *this;
  }
  inline Envelope& operator=(Envelope&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Envelope& default_instance() {
    return *internal_default_instance();
  }
  static inline const Envelope* internal_default_instance() {
    return reinterpret_cast<const Envelope*>(
        &_Envelope_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Envelope& a, Envelope& b) { a.Swap(&b); }
  inline void Swap(Envelope* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Envelope* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Envelope* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<Envelope>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Envelope& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Envelope& from) { Envelope::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Envelope* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.Envelope"; }

 protected:
  explicit Envelope(::google::protobuf::Arena* arena);
  Envelope(::google::protobuf::Arena* arena, const Envelope& from);
  Envelope(::google::protobuf::Arena* arena, Envelope&& from) noexcept
      : Envelope(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kVersionFieldNumber = 1,
    kSubmitterFieldNumber = 2,
  };
  // .keti.Version version = 1;
  bool has_version() const;
  void clear_version() ;
  const ::keti::Version& version() const;
  PROTOBUF_NODISCARD ::keti::Version* release_version();
  ::keti::Version* mutable_version();
  void set_allocated_version(::keti::Version* value);
  void unsafe_arena_set_allocated_version(::keti::Version* value);
  ::keti::Version* unsafe_arena_release_version();

  private:
  const ::keti::Version& _internal_version() const;
  ::keti::Version* _internal_mutable_version();

  public:
  // .keti.Entity submitter = 2;
  bool has_submitter() const;
  void clear_submitter() ;
  const ::keti::Entity& submitter() const;
  PROTOBUF_NODISCARD ::keti::Entity* release_submitter();
  ::keti::Entity* mutable_submitter();
  void set_allocated_submitter(::keti::Entity* value);
  void unsafe_arena_set_allocated_submitter(::keti::Entity* value);
  ::keti::Entity* unsafe_arena_release_submitter();

  private:
  const ::keti::Entity& _internal_submitter() const;
  ::keti::Entity* _internal_mutable_submitter();

  public:
  // @@protoc_insertion_point(class_scope:keti.Envelope)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Envelope_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Envelope& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::keti::Version* version_;
    ::keti::Entity* submitter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicleAbnormalDataStream final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicleAbnormalDataStream) */ {
 public:
  inline AvpVehicleAbnormalDataStream() : AvpVehicleAbnormalDataStream(nullptr) {}
  ~AvpVehicleAbnormalDataStream() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicleAbnormalDataStream(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicleAbnormalDataStream(const AvpVehicleAbnormalDataStream& from) : AvpVehicleAbnormalDataStream(nullptr, from) {}
  inline AvpVehicleAbnormalDataStream(AvpVehicleAbnormalDataStream&& from) noexcept
      : AvpVehicleAbnormalDataStream(nullptr, std::move(from)) {}
  inline AvpVehicleAbnormalDataStream& operator=(const AvpVehicleAbnormalDataStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicleAbnormalDataStream& operator=(AvpVehicleAbnormalDataStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicleAbnormalDataStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicleAbnormalDataStream* internal_default_instance() {
    return reinterpret_cast<const AvpVehicleAbnormalDataStream*>(
        &_AvpVehicleAbnormalDataStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AvpVehicleAbnormalDataStream& a, AvpVehicleAbnormalDataStream& b) { a.Swap(&b); }
  inline void Swap(AvpVehicleAbnormalDataStream* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicleAbnormalDataStream* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicleAbnormalDataStream* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicleAbnormalDataStream>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicleAbnormalDataStream& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicleAbnormalDataStream& from) { AvpVehicleAbnormalDataStream::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicleAbnormalDataStream* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicleAbnormalDataStream"; }

 protected:
  explicit AvpVehicleAbnormalDataStream(::google::protobuf::Arena* arena);
  AvpVehicleAbnormalDataStream(::google::protobuf::Arena* arena, const AvpVehicleAbnormalDataStream& from);
  AvpVehicleAbnormalDataStream(::google::protobuf::Arena* arena, AvpVehicleAbnormalDataStream&& from) noexcept
      : AvpVehicleAbnormalDataStream(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .keti.AvpVehicleAbnormalData data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::keti::AvpVehicleAbnormalData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>* _internal_mutable_data();
  public:
  const ::keti::AvpVehicleAbnormalData& data(int index) const;
  ::keti::AvpVehicleAbnormalData* add_data();
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>& data() const;
  // @@protoc_insertion_point(class_scope:keti.AvpVehicleAbnormalDataStream)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicleAbnormalDataStream_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicleAbnormalDataStream& from_msg);
    ::google::protobuf::RepeatedPtrField< ::keti::AvpVehicleAbnormalData > data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpVehicle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpVehicle) */ {
 public:
  inline AvpVehicle() : AvpVehicle(nullptr) {}
  ~AvpVehicle() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpVehicle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpVehicle(const AvpVehicle& from) : AvpVehicle(nullptr, from) {}
  inline AvpVehicle(AvpVehicle&& from) noexcept
      : AvpVehicle(nullptr, std::move(from)) {}
  inline AvpVehicle& operator=(const AvpVehicle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpVehicle& operator=(AvpVehicle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpVehicle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpVehicle* internal_default_instance() {
    return reinterpret_cast<const AvpVehicle*>(
        &_AvpVehicle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AvpVehicle& a, AvpVehicle& b) { a.Swap(&b); }
  inline void Swap(AvpVehicle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpVehicle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpVehicle* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpVehicle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpVehicle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpVehicle& from) { AvpVehicle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpVehicle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpVehicle"; }

 protected:
  explicit AvpVehicle(::google::protobuf::Arena* arena);
  AvpVehicle(::google::protobuf::Arena* arena, const AvpVehicle& from);
  AvpVehicle(::google::protobuf::Arena* arena, AvpVehicle&& from) noexcept
      : AvpVehicle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 2,
    kPosFieldNumber = 1,
  };
  // string id = 2;
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // .keti.AvpVehiclePos pos = 1;
  bool has_pos() const;
  void clear_pos() ;
  const ::keti::AvpVehiclePos& pos() const;
  PROTOBUF_NODISCARD ::keti::AvpVehiclePos* release_pos();
  ::keti::AvpVehiclePos* mutable_pos();
  void set_allocated_pos(::keti::AvpVehiclePos* value);
  void unsafe_arena_set_allocated_pos(::keti::AvpVehiclePos* value);
  ::keti::AvpVehiclePos* unsafe_arena_release_pos();

  private:
  const ::keti::AvpVehiclePos& _internal_pos() const;
  ::keti::AvpVehiclePos* _internal_mutable_pos();

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpVehicle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      26, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpVehicle_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpVehicle& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::keti::AvpVehiclePos* pos_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpDataMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpDataMessage) */ {
 public:
  inline AvpDataMessage() : AvpDataMessage(nullptr) {}
  ~AvpDataMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpDataMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpDataMessage(const AvpDataMessage& from) : AvpDataMessage(nullptr, from) {}
  inline AvpDataMessage(AvpDataMessage&& from) noexcept
      : AvpDataMessage(nullptr, std::move(from)) {}
  inline AvpDataMessage& operator=(const AvpDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpDataMessage& operator=(AvpDataMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpDataMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpDataMessage* internal_default_instance() {
    return reinterpret_cast<const AvpDataMessage*>(
        &_AvpDataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AvpDataMessage& a, AvpDataMessage& b) { a.Swap(&b); }
  inline void Swap(AvpDataMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpDataMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpDataMessage* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpDataMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpDataMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpDataMessage& from) { AvpDataMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpDataMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpDataMessage"; }

 protected:
  explicit AvpDataMessage(::google::protobuf::Arena* arena);
  AvpDataMessage(::google::protobuf::Arena* arena, const AvpDataMessage& from);
  AvpDataMessage(::google::protobuf::Arena* arena, AvpDataMessage&& from) noexcept
      : AvpDataMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .keti.AvpCANSensorData data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  ::keti::AvpCANSensorData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>* _internal_mutable_data();
  public:
  const ::keti::AvpCANSensorData& data(int index) const;
  ::keti::AvpCANSensorData* add_data();
  const ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>& data() const;
  // @@protoc_insertion_point(class_scope:keti.AvpDataMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpDataMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpDataMessage& from_msg);
    ::google::protobuf::RepeatedPtrField< ::keti::AvpCANSensorData > data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpMessage) */ {
 public:
  inline AvpMessage() : AvpMessage(nullptr) {}
  ~AvpMessage() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpMessage(const AvpMessage& from) : AvpMessage(nullptr, from) {}
  inline AvpMessage(AvpMessage&& from) noexcept
      : AvpMessage(nullptr, std::move(from)) {}
  inline AvpMessage& operator=(const AvpMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpMessage& operator=(AvpMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kCtrl = 3,
    kData = 4,
    MESSAGE_NOT_SET = 0,
  };
  static inline const AvpMessage* internal_default_instance() {
    return reinterpret_cast<const AvpMessage*>(
        &_AvpMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AvpMessage& a, AvpMessage& b) { a.Swap(&b); }
  inline void Swap(AvpMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpMessage* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpMessage& from) { AvpMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpMessage"; }

 protected:
  explicit AvpMessage(::google::protobuf::Arena* arena);
  AvpMessage(::google::protobuf::Arena* arena, const AvpMessage& from);
  AvpMessage(::google::protobuf::Arena* arena, AvpMessage&& from) noexcept
      : AvpMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEnvelopeFieldNumber = 1,
    kIdFieldNumber = 2,
    kCtrlFieldNumber = 3,
    kDataFieldNumber = 4,
  };
  // .keti.Envelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope() ;
  const ::keti::Envelope& envelope() const;
  PROTOBUF_NODISCARD ::keti::Envelope* release_envelope();
  ::keti::Envelope* mutable_envelope();
  void set_allocated_envelope(::keti::Envelope* value);
  void unsafe_arena_set_allocated_envelope(::keti::Envelope* value);
  ::keti::Envelope* unsafe_arena_release_envelope();

  private:
  const ::keti::Envelope& _internal_envelope() const;
  ::keti::Envelope* _internal_mutable_envelope();

  public:
  // .keti.Ids id = 2;
  bool has_id() const;
  void clear_id() ;
  const ::keti::Ids& id() const;
  PROTOBUF_NODISCARD ::keti::Ids* release_id();
  ::keti::Ids* mutable_id();
  void set_allocated_id(::keti::Ids* value);
  void unsafe_arena_set_allocated_id(::keti::Ids* value);
  ::keti::Ids* unsafe_arena_release_id();

  private:
  const ::keti::Ids& _internal_id() const;
  ::keti::Ids* _internal_mutable_id();

  public:
  // .keti.AvpControlMessage ctrl = 3;
  bool has_ctrl() const;
  private:
  bool _internal_has_ctrl() const;

  public:
  void clear_ctrl() ;
  const ::keti::AvpControlMessage& ctrl() const;
  PROTOBUF_NODISCARD ::keti::AvpControlMessage* release_ctrl();
  ::keti::AvpControlMessage* mutable_ctrl();
  void set_allocated_ctrl(::keti::AvpControlMessage* value);
  void unsafe_arena_set_allocated_ctrl(::keti::AvpControlMessage* value);
  ::keti::AvpControlMessage* unsafe_arena_release_ctrl();

  private:
  const ::keti::AvpControlMessage& _internal_ctrl() const;
  ::keti::AvpControlMessage* _internal_mutable_ctrl();

  public:
  // .keti.AvpDataMessage data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;

  public:
  void clear_data() ;
  const ::keti::AvpDataMessage& data() const;
  PROTOBUF_NODISCARD ::keti::AvpDataMessage* release_data();
  ::keti::AvpDataMessage* mutable_data();
  void set_allocated_data(::keti::AvpDataMessage* value);
  void unsafe_arena_set_allocated_data(::keti::AvpDataMessage* value);
  ::keti::AvpDataMessage* unsafe_arena_release_data();

  private:
  const ::keti::AvpDataMessage& _internal_data() const;
  ::keti::AvpDataMessage* _internal_mutable_data();

  public:
  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:keti.AvpMessage)
 private:
  class _Internal;
  void set_has_ctrl();
  void set_has_data();
  inline bool has_message() const;
  inline void clear_has_message();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpMessage& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::keti::Envelope* envelope_;
    ::keti::Ids* id_;
    union MessageUnion {
      constexpr MessageUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::keti::AvpControlMessage* ctrl_;
      ::keti::AvpDataMessage* data_;
    } message_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};
// -------------------------------------------------------------------

class AvpCCTVMonitoringData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:keti.AvpCCTVMonitoringData) */ {
 public:
  inline AvpCCTVMonitoringData() : AvpCCTVMonitoringData(nullptr) {}
  ~AvpCCTVMonitoringData() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AvpCCTVMonitoringData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AvpCCTVMonitoringData(const AvpCCTVMonitoringData& from) : AvpCCTVMonitoringData(nullptr, from) {}
  inline AvpCCTVMonitoringData(AvpCCTVMonitoringData&& from) noexcept
      : AvpCCTVMonitoringData(nullptr, std::move(from)) {}
  inline AvpCCTVMonitoringData& operator=(const AvpCCTVMonitoringData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvpCCTVMonitoringData& operator=(AvpCCTVMonitoringData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvpCCTVMonitoringData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvpCCTVMonitoringData* internal_default_instance() {
    return reinterpret_cast<const AvpCCTVMonitoringData*>(
        &_AvpCCTVMonitoringData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AvpCCTVMonitoringData& a, AvpCCTVMonitoringData& b) { a.Swap(&b); }
  inline void Swap(AvpCCTVMonitoringData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvpCCTVMonitoringData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvpCCTVMonitoringData* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<AvpCCTVMonitoringData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AvpCCTVMonitoringData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AvpCCTVMonitoringData& from) { AvpCCTVMonitoringData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AvpCCTVMonitoringData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "keti.AvpCCTVMonitoringData"; }

 protected:
  explicit AvpCCTVMonitoringData(::google::protobuf::Arena* arena);
  AvpCCTVMonitoringData(::google::protobuf::Arena* arena, const AvpCCTVMonitoringData& from);
  AvpCCTVMonitoringData(::google::protobuf::Arena* arena, AvpCCTVMonitoringData&& from) noexcept
      : AvpCCTVMonitoringData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAvpCarsFieldNumber = 2,
    kCarsFieldNumber = 3,
    kPersonsFieldNumber = 4,
    kTimeFieldNumber = 1,
    kSpacesFieldNumber = 5,
  };
  // repeated .keti.AvpVehicle avp_cars = 2;
  int avp_cars_size() const;
  private:
  int _internal_avp_cars_size() const;

  public:
  void clear_avp_cars() ;
  ::keti::AvpVehicle* mutable_avp_cars(int index);
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* mutable_avp_cars();

  private:
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& _internal_avp_cars() const;
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* _internal_mutable_avp_cars();
  public:
  const ::keti::AvpVehicle& avp_cars(int index) const;
  ::keti::AvpVehicle* add_avp_cars();
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& avp_cars() const;
  // repeated .keti.AvpVehicle cars = 3;
  int cars_size() const;
  private:
  int _internal_cars_size() const;

  public:
  void clear_cars() ;
  ::keti::AvpVehicle* mutable_cars(int index);
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* mutable_cars();

  private:
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& _internal_cars() const;
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* _internal_mutable_cars();
  public:
  const ::keti::AvpVehicle& cars(int index) const;
  ::keti::AvpVehicle* add_cars();
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& cars() const;
  // repeated .keti.AvpVehiclePos persons = 4;
  int persons_size() const;
  private:
  int _internal_persons_size() const;

  public:
  void clear_persons() ;
  ::keti::AvpVehiclePos* mutable_persons(int index);
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>* mutable_persons();

  private:
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>& _internal_persons() const;
  ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>* _internal_mutable_persons();
  public:
  const ::keti::AvpVehiclePos& persons(int index) const;
  ::keti::AvpVehiclePos* add_persons();
  const ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>& persons() const;
  // .google.protobuf.Timestamp time = 1;
  bool has_time() const;
  void clear_time() ;
  const ::google::protobuf::Timestamp& time() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_time();
  ::google::protobuf::Timestamp* mutable_time();
  void set_allocated_time(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_time();

  private:
  const ::google::protobuf::Timestamp& _internal_time() const;
  ::google::protobuf::Timestamp* _internal_mutable_time();

  public:
  // .keti.AvpParkingSpaces spaces = 5;
  bool has_spaces() const;
  void clear_spaces() ;
  const ::keti::AvpParkingSpaces& spaces() const;
  PROTOBUF_NODISCARD ::keti::AvpParkingSpaces* release_spaces();
  ::keti::AvpParkingSpaces* mutable_spaces();
  void set_allocated_spaces(::keti::AvpParkingSpaces* value);
  void unsafe_arena_set_allocated_spaces(::keti::AvpParkingSpaces* value);
  ::keti::AvpParkingSpaces* unsafe_arena_release_spaces();

  private:
  const ::keti::AvpParkingSpaces& _internal_spaces() const;
  ::keti::AvpParkingSpaces* _internal_mutable_spaces();

  public:
  // @@protoc_insertion_point(class_scope:keti.AvpCCTVMonitoringData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 5,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AvpCCTVMonitoringData_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AvpCCTVMonitoringData& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::keti::AvpVehicle > avp_cars_;
    ::google::protobuf::RepeatedPtrField< ::keti::AvpVehicle > cars_;
    ::google::protobuf::RepeatedPtrField< ::keti::AvpVehiclePos > persons_;
    ::google::protobuf::Timestamp* time_;
    ::keti::AvpParkingSpaces* spaces_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Avp_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Version

// uint32 major = 1;
inline void Version::clear_major() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.major_ = 0u;
}
inline ::uint32_t Version::major() const {
  // @@protoc_insertion_point(field_get:keti.Version.major)
  return _internal_major();
}
inline void Version::set_major(::uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:keti.Version.major)
}
inline ::uint32_t Version::_internal_major() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.major_;
}
inline void Version::_internal_set_major(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.major_ = value;
}

// uint32 minor = 2;
inline void Version::clear_minor() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_ = 0u;
}
inline ::uint32_t Version::minor() const {
  // @@protoc_insertion_point(field_get:keti.Version.minor)
  return _internal_minor();
}
inline void Version::set_minor(::uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:keti.Version.minor)
}
inline ::uint32_t Version::_internal_minor() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.minor_;
}
inline void Version::_internal_set_minor(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.minor_ = value;
}

// uint32 patch = 3;
inline void Version::clear_patch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patch_ = 0u;
}
inline ::uint32_t Version::patch() const {
  // @@protoc_insertion_point(field_get:keti.Version.patch)
  return _internal_patch();
}
inline void Version::set_patch(::uint32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:keti.Version.patch)
}
inline ::uint32_t Version::_internal_patch() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.patch_;
}
inline void Version::_internal_set_patch(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.patch_ = value;
}

// -------------------------------------------------------------------

// Entity

// string primary_id = 1;
inline void Entity::clear_primary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_id_.ClearToEmpty();
}
inline const std::string& Entity::primary_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Entity.primary_id)
  return _internal_primary_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_primary_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:keti.Entity.primary_id)
}
inline std::string* Entity::mutable_primary_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_primary_id();
  // @@protoc_insertion_point(field_mutable:keti.Entity.primary_id)
  return _s;
}
inline const std::string& Entity::_internal_primary_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.primary_id_.Get();
}
inline void Entity::_internal_set_primary_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_id_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_primary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.primary_id_.Mutable( GetArena());
}
inline std::string* Entity::release_primary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Entity.primary_id)
  return _impl_.primary_id_.Release();
}
inline void Entity::set_allocated_primary_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.primary_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.primary_id_.IsDefault()) {
          _impl_.primary_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keti.Entity.primary_id)
}

// string secondary_id = 2;
inline void Entity::clear_secondary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_id_.ClearToEmpty();
}
inline const std::string& Entity::secondary_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Entity.secondary_id)
  return _internal_secondary_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_secondary_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:keti.Entity.secondary_id)
}
inline std::string* Entity::mutable_secondary_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secondary_id();
  // @@protoc_insertion_point(field_mutable:keti.Entity.secondary_id)
  return _s;
}
inline const std::string& Entity::_internal_secondary_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secondary_id_.Get();
}
inline void Entity::_internal_set_secondary_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_id_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_secondary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secondary_id_.Mutable( GetArena());
}
inline std::string* Entity::release_secondary_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Entity.secondary_id)
  return _impl_.secondary_id_.Release();
}
inline void Entity::set_allocated_secondary_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secondary_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secondary_id_.IsDefault()) {
          _impl_.secondary_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keti.Entity.secondary_id)
}

// string type = 3;
inline void Entity::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& Entity::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Entity.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Entity::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:keti.Entity.type)
}
inline std::string* Entity::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:keti.Entity.type)
  return _s;
}
inline const std::string& Entity::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void Entity::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* Entity::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* Entity::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Entity.type)
  return _impl_.type_.Release();
}
inline void Entity::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keti.Entity.type)
}

// .keti.Version software_version = 4;
inline bool Entity::has_software_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.software_version_ != nullptr);
  return value;
}
inline void Entity::clear_software_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.software_version_ != nullptr) _impl_.software_version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::keti::Version& Entity::_internal_software_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Version* p = _impl_.software_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Version&>(::keti::_Version_default_instance_);
}
inline const ::keti::Version& Entity::software_version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Entity.software_version)
  return _internal_software_version();
}
inline void Entity::unsafe_arena_set_allocated_software_version(::keti::Version* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.software_version_);
  }
  _impl_.software_version_ = reinterpret_cast<::keti::Version*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.Entity.software_version)
}
inline ::keti::Version* Entity::release_software_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Version* released = _impl_.software_version_;
  _impl_.software_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Version* Entity::unsafe_arena_release_software_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Entity.software_version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Version* temp = _impl_.software_version_;
  _impl_.software_version_ = nullptr;
  return temp;
}
inline ::keti::Version* Entity::_internal_mutable_software_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.software_version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Version>(GetArena());
    _impl_.software_version_ = reinterpret_cast<::keti::Version*>(p);
  }
  return _impl_.software_version_;
}
inline ::keti::Version* Entity::mutable_software_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::keti::Version* _msg = _internal_mutable_software_version();
  // @@protoc_insertion_point(field_mutable:keti.Entity.software_version)
  return _msg;
}
inline void Entity::set_allocated_software_version(::keti::Version* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.software_version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.software_version_ = reinterpret_cast<::keti::Version*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.Entity.software_version)
}

// .keti.Version hardware_version = 5;
inline bool Entity::has_hardware_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hardware_version_ != nullptr);
  return value;
}
inline void Entity::clear_hardware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_version_ != nullptr) _impl_.hardware_version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::Version& Entity::_internal_hardware_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Version* p = _impl_.hardware_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Version&>(::keti::_Version_default_instance_);
}
inline const ::keti::Version& Entity::hardware_version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Entity.hardware_version)
  return _internal_hardware_version();
}
inline void Entity::unsafe_arena_set_allocated_hardware_version(::keti::Version* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.hardware_version_);
  }
  _impl_.hardware_version_ = reinterpret_cast<::keti::Version*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.Entity.hardware_version)
}
inline ::keti::Version* Entity::release_hardware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Version* released = _impl_.hardware_version_;
  _impl_.hardware_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Version* Entity::unsafe_arena_release_hardware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Entity.hardware_version)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Version* temp = _impl_.hardware_version_;
  _impl_.hardware_version_ = nullptr;
  return temp;
}
inline ::keti::Version* Entity::_internal_mutable_hardware_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.hardware_version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Version>(GetArena());
    _impl_.hardware_version_ = reinterpret_cast<::keti::Version*>(p);
  }
  return _impl_.hardware_version_;
}
inline ::keti::Version* Entity::mutable_hardware_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::Version* _msg = _internal_mutable_hardware_version();
  // @@protoc_insertion_point(field_mutable:keti.Entity.hardware_version)
  return _msg;
}
inline void Entity::set_allocated_hardware_version(::keti::Version* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.hardware_version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.hardware_version_ = reinterpret_cast<::keti::Version*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.Entity.hardware_version)
}

// -------------------------------------------------------------------

// Envelope

// .keti.Version version = 1;
inline bool Envelope::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.version_ != nullptr);
  return value;
}
inline void Envelope::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ != nullptr) _impl_.version_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::keti::Version& Envelope::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Version&>(::keti::_Version_default_instance_);
}
inline const ::keti::Version& Envelope::version() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Envelope.version)
  return _internal_version();
}
inline void Envelope::unsafe_arena_set_allocated_version(::keti::Version* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = reinterpret_cast<::keti::Version*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.Envelope.version)
}
inline ::keti::Version* Envelope::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Version* released = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Version* Envelope::unsafe_arena_release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Envelope.version)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::keti::Version* Envelope::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.version_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Version>(GetArena());
    _impl_.version_ = reinterpret_cast<::keti::Version*>(p);
  }
  return _impl_.version_;
}
inline ::keti::Version* Envelope::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::keti::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:keti.Envelope.version)
  return _msg;
}
inline void Envelope::set_allocated_version(::keti::Version* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.version_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.version_ = reinterpret_cast<::keti::Version*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.Envelope.version)
}

// .keti.Entity submitter = 2;
inline bool Envelope::has_submitter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.submitter_ != nullptr);
  return value;
}
inline void Envelope::clear_submitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.submitter_ != nullptr) _impl_.submitter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::Entity& Envelope::_internal_submitter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Entity* p = _impl_.submitter_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Entity&>(::keti::_Entity_default_instance_);
}
inline const ::keti::Entity& Envelope::submitter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Envelope.submitter)
  return _internal_submitter();
}
inline void Envelope::unsafe_arena_set_allocated_submitter(::keti::Entity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.submitter_);
  }
  _impl_.submitter_ = reinterpret_cast<::keti::Entity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.Envelope.submitter)
}
inline ::keti::Entity* Envelope::release_submitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Entity* released = _impl_.submitter_;
  _impl_.submitter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Entity* Envelope::unsafe_arena_release_submitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Envelope.submitter)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Entity* temp = _impl_.submitter_;
  _impl_.submitter_ = nullptr;
  return temp;
}
inline ::keti::Entity* Envelope::_internal_mutable_submitter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.submitter_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Entity>(GetArena());
    _impl_.submitter_ = reinterpret_cast<::keti::Entity*>(p);
  }
  return _impl_.submitter_;
}
inline ::keti::Entity* Envelope::mutable_submitter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::Entity* _msg = _internal_mutable_submitter();
  // @@protoc_insertion_point(field_mutable:keti.Envelope.submitter)
  return _msg;
}
inline void Envelope::set_allocated_submitter(::keti::Entity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.submitter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.submitter_ = reinterpret_cast<::keti::Entity*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.Envelope.submitter)
}

// -------------------------------------------------------------------

// Ids

// string session_id = 1;
inline void Ids::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& Ids::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.Ids.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Ids::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:keti.Ids.session_id)
}
inline std::string* Ids::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:keti.Ids.session_id)
  return _s;
}
inline const std::string& Ids::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void Ids::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* Ids::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* Ids::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.Ids.session_id)
  return _impl_.session_id_.Release();
}
inline void Ids::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keti.Ids.session_id)
}

// int32 message_id = 2;
inline void Ids::clear_message_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = 0;
}
inline ::int32_t Ids::message_id() const {
  // @@protoc_insertion_point(field_get:keti.Ids.message_id)
  return _internal_message_id();
}
inline void Ids::set_message_id(::int32_t value) {
  _internal_set_message_id(value);
  // @@protoc_insertion_point(field_set:keti.Ids.message_id)
}
inline ::int32_t Ids::_internal_message_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_id_;
}
inline void Ids::_internal_set_message_id(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_id_ = value;
}

// -------------------------------------------------------------------

// AvpVehicleAbnormalData

// .google.protobuf.Timestamp time = 1;
inline bool AvpVehicleAbnormalData::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AvpVehicleAbnormalData::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AvpVehicleAbnormalData::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleAbnormalData.time)
  return _internal_time();
}
inline void AvpVehicleAbnormalData::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpVehicleAbnormalData.time)
}
inline ::google::protobuf::Timestamp* AvpVehicleAbnormalData::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AvpVehicleAbnormalData::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpVehicleAbnormalData.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AvpVehicleAbnormalData::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* AvpVehicleAbnormalData::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:keti.AvpVehicleAbnormalData.time)
  return _msg;
}
inline void AvpVehicleAbnormalData::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpVehicleAbnormalData.time)
}

// .keti.AvpVehicleAbnormalData.AbnormalType type = 2;
inline void AvpVehicleAbnormalData::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::keti::AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::type() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleAbnormalData.type)
  return _internal_type();
}
inline void AvpVehicleAbnormalData::set_type(::keti::AvpVehicleAbnormalData_AbnormalType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleAbnormalData.type)
}
inline ::keti::AvpVehicleAbnormalData_AbnormalType AvpVehicleAbnormalData::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::keti::AvpVehicleAbnormalData_AbnormalType>(_impl_.type_);
}
inline void AvpVehicleAbnormalData::_internal_set_type(::keti::AvpVehicleAbnormalData_AbnormalType value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// AvpVehicleAbnormalDataStream

// repeated .keti.AvpVehicleAbnormalData data = 1;
inline int AvpVehicleAbnormalDataStream::_internal_data_size() const {
  return _internal_data().size();
}
inline int AvpVehicleAbnormalDataStream::data_size() const {
  return _internal_data_size();
}
inline void AvpVehicleAbnormalDataStream::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::keti::AvpVehicleAbnormalData* AvpVehicleAbnormalDataStream::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:keti.AvpVehicleAbnormalDataStream.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>* AvpVehicleAbnormalDataStream::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpVehicleAbnormalDataStream.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::keti::AvpVehicleAbnormalData& AvpVehicleAbnormalDataStream::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleAbnormalDataStream.data)
  return _internal_data().Get(index);
}
inline ::keti::AvpVehicleAbnormalData* AvpVehicleAbnormalDataStream::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::keti::AvpVehicleAbnormalData* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:keti.AvpVehicleAbnormalDataStream.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>& AvpVehicleAbnormalDataStream::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpVehicleAbnormalDataStream.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>&
AvpVehicleAbnormalDataStream::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicleAbnormalData>*
AvpVehicleAbnormalDataStream::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// AvpGridPos

// int32 x = 1;
inline void AvpGridPos::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline ::int32_t AvpGridPos::x() const {
  // @@protoc_insertion_point(field_get:keti.AvpGridPos.x)
  return _internal_x();
}
inline void AvpGridPos::set_x(::int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:keti.AvpGridPos.x)
}
inline ::int32_t AvpGridPos::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void AvpGridPos::_internal_set_x(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// int32 y = 2;
inline void AvpGridPos::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline ::int32_t AvpGridPos::y() const {
  // @@protoc_insertion_point(field_get:keti.AvpGridPos.y)
  return _internal_y();
}
inline void AvpGridPos::set_y(::int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:keti.AvpGridPos.y)
}
inline ::int32_t AvpGridPos::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void AvpGridPos::_internal_set_y(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// AvpVehiclePos

// .keti.AvpGridPos pos1 = 1;
inline bool AvpVehiclePos::has_pos1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos1_ != nullptr);
  return value;
}
inline void AvpVehiclePos::clear_pos1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos1_ != nullptr) _impl_.pos1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::keti::AvpGridPos& AvpVehiclePos::_internal_pos1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpGridPos* p = _impl_.pos1_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpGridPos&>(::keti::_AvpGridPos_default_instance_);
}
inline const ::keti::AvpGridPos& AvpVehiclePos::pos1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehiclePos.pos1)
  return _internal_pos1();
}
inline void AvpVehiclePos::unsafe_arena_set_allocated_pos1(::keti::AvpGridPos* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos1_);
  }
  _impl_.pos1_ = reinterpret_cast<::keti::AvpGridPos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpVehiclePos.pos1)
}
inline ::keti::AvpGridPos* AvpVehiclePos::release_pos1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::AvpGridPos* released = _impl_.pos1_;
  _impl_.pos1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpGridPos* AvpVehiclePos::unsafe_arena_release_pos1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpVehiclePos.pos1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::AvpGridPos* temp = _impl_.pos1_;
  _impl_.pos1_ = nullptr;
  return temp;
}
inline ::keti::AvpGridPos* AvpVehiclePos::_internal_mutable_pos1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos1_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpGridPos>(GetArena());
    _impl_.pos1_ = reinterpret_cast<::keti::AvpGridPos*>(p);
  }
  return _impl_.pos1_;
}
inline ::keti::AvpGridPos* AvpVehiclePos::mutable_pos1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::keti::AvpGridPos* _msg = _internal_mutable_pos1();
  // @@protoc_insertion_point(field_mutable:keti.AvpVehiclePos.pos1)
  return _msg;
}
inline void AvpVehiclePos::set_allocated_pos1(::keti::AvpGridPos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos1_ = reinterpret_cast<::keti::AvpGridPos*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpVehiclePos.pos1)
}

// .keti.AvpGridPos pos2 = 2;
inline bool AvpVehiclePos::has_pos2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos2_ != nullptr);
  return value;
}
inline void AvpVehiclePos::clear_pos2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos2_ != nullptr) _impl_.pos2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::AvpGridPos& AvpVehiclePos::_internal_pos2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpGridPos* p = _impl_.pos2_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpGridPos&>(::keti::_AvpGridPos_default_instance_);
}
inline const ::keti::AvpGridPos& AvpVehiclePos::pos2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehiclePos.pos2)
  return _internal_pos2();
}
inline void AvpVehiclePos::unsafe_arena_set_allocated_pos2(::keti::AvpGridPos* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos2_);
  }
  _impl_.pos2_ = reinterpret_cast<::keti::AvpGridPos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpVehiclePos.pos2)
}
inline ::keti::AvpGridPos* AvpVehiclePos::release_pos2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpGridPos* released = _impl_.pos2_;
  _impl_.pos2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpGridPos* AvpVehiclePos::unsafe_arena_release_pos2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpVehiclePos.pos2)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpGridPos* temp = _impl_.pos2_;
  _impl_.pos2_ = nullptr;
  return temp;
}
inline ::keti::AvpGridPos* AvpVehiclePos::_internal_mutable_pos2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos2_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpGridPos>(GetArena());
    _impl_.pos2_ = reinterpret_cast<::keti::AvpGridPos*>(p);
  }
  return _impl_.pos2_;
}
inline ::keti::AvpGridPos* AvpVehiclePos::mutable_pos2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::AvpGridPos* _msg = _internal_mutable_pos2();
  // @@protoc_insertion_point(field_mutable:keti.AvpVehiclePos.pos2)
  return _msg;
}
inline void AvpVehiclePos::set_allocated_pos2(::keti::AvpGridPos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pos2_ = reinterpret_cast<::keti::AvpGridPos*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpVehiclePos.pos2)
}

// -------------------------------------------------------------------

// AvpVehicle

// .keti.AvpVehiclePos pos = 1;
inline bool AvpVehicle::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void AvpVehicle::clear_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::keti::AvpVehiclePos& AvpVehicle::_internal_pos() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpVehiclePos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpVehiclePos&>(::keti::_AvpVehiclePos_default_instance_);
}
inline const ::keti::AvpVehiclePos& AvpVehicle::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehicle.pos)
  return _internal_pos();
}
inline void AvpVehicle::unsafe_arena_set_allocated_pos(::keti::AvpVehiclePos* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::keti::AvpVehiclePos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpVehicle.pos)
}
inline ::keti::AvpVehiclePos* AvpVehicle::release_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::AvpVehiclePos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpVehiclePos* AvpVehicle::unsafe_arena_release_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpVehicle.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::AvpVehiclePos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::keti::AvpVehiclePos* AvpVehicle::_internal_mutable_pos() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpVehiclePos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::keti::AvpVehiclePos*>(p);
  }
  return _impl_.pos_;
}
inline ::keti::AvpVehiclePos* AvpVehicle::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::keti::AvpVehiclePos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:keti.AvpVehicle.pos)
  return _msg;
}
inline void AvpVehicle::set_allocated_pos(::keti::AvpVehiclePos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::keti::AvpVehiclePos*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpVehicle.pos)
}

// string id = 2;
inline void AvpVehicle::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& AvpVehicle::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpVehicle.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AvpVehicle::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:keti.AvpVehicle.id)
}
inline std::string* AvpVehicle::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:keti.AvpVehicle.id)
  return _s;
}
inline const std::string& AvpVehicle::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void AvpVehicle::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* AvpVehicle::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* AvpVehicle::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpVehicle.id)
  return _impl_.id_.Release();
}
inline void AvpVehicle::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keti.AvpVehicle.id)
}

// -------------------------------------------------------------------

// AvpParkingSpaces

// repeated bool parked = 1;
inline int AvpParkingSpaces::_internal_parked_size() const {
  return _internal_parked().size();
}
inline int AvpParkingSpaces::parked_size() const {
  return _internal_parked_size();
}
inline void AvpParkingSpaces::clear_parked() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parked_.Clear();
}
inline bool AvpParkingSpaces::parked(int index) const {
  // @@protoc_insertion_point(field_get:keti.AvpParkingSpaces.parked)
  return _internal_parked().Get(index);
}
inline void AvpParkingSpaces::set_parked(int index, bool value) {
  _internal_mutable_parked()->Set(index, value);
  // @@protoc_insertion_point(field_set:keti.AvpParkingSpaces.parked)
}
inline void AvpParkingSpaces::add_parked(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_parked()->Add(value);
  // @@protoc_insertion_point(field_add:keti.AvpParkingSpaces.parked)
}
inline const ::google::protobuf::RepeatedField<bool>& AvpParkingSpaces::parked() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpParkingSpaces.parked)
  return _internal_parked();
}
inline ::google::protobuf::RepeatedField<bool>* AvpParkingSpaces::mutable_parked()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpParkingSpaces.parked)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_parked();
}
inline const ::google::protobuf::RepeatedField<bool>&
AvpParkingSpaces::_internal_parked() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parked_;
}
inline ::google::protobuf::RepeatedField<bool>* AvpParkingSpaces::_internal_mutable_parked() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.parked_;
}

// -------------------------------------------------------------------

// AvpCCTVMonitoringData

// .google.protobuf.Timestamp time = 1;
inline bool AvpCCTVMonitoringData::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AvpCCTVMonitoringData::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AvpCCTVMonitoringData::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCCTVMonitoringData.time)
  return _internal_time();
}
inline void AvpCCTVMonitoringData::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCCTVMonitoringData.time)
}
inline ::google::protobuf::Timestamp* AvpCCTVMonitoringData::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AvpCCTVMonitoringData::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCCTVMonitoringData.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AvpCCTVMonitoringData::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* AvpCCTVMonitoringData::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:keti.AvpCCTVMonitoringData.time)
  return _msg;
}
inline void AvpCCTVMonitoringData::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCCTVMonitoringData.time)
}

// repeated .keti.AvpVehicle avp_cars = 2;
inline int AvpCCTVMonitoringData::_internal_avp_cars_size() const {
  return _internal_avp_cars().size();
}
inline int AvpCCTVMonitoringData::avp_cars_size() const {
  return _internal_avp_cars_size();
}
inline void AvpCCTVMonitoringData::clear_avp_cars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.avp_cars_.Clear();
}
inline ::keti::AvpVehicle* AvpCCTVMonitoringData::mutable_avp_cars(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:keti.AvpCCTVMonitoringData.avp_cars)
  return _internal_mutable_avp_cars()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* AvpCCTVMonitoringData::mutable_avp_cars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpCCTVMonitoringData.avp_cars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_avp_cars();
}
inline const ::keti::AvpVehicle& AvpCCTVMonitoringData::avp_cars(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCCTVMonitoringData.avp_cars)
  return _internal_avp_cars().Get(index);
}
inline ::keti::AvpVehicle* AvpCCTVMonitoringData::add_avp_cars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::keti::AvpVehicle* _add = _internal_mutable_avp_cars()->Add();
  // @@protoc_insertion_point(field_add:keti.AvpCCTVMonitoringData.avp_cars)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& AvpCCTVMonitoringData::avp_cars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpCCTVMonitoringData.avp_cars)
  return _internal_avp_cars();
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>&
AvpCCTVMonitoringData::_internal_avp_cars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.avp_cars_;
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>*
AvpCCTVMonitoringData::_internal_mutable_avp_cars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.avp_cars_;
}

// repeated .keti.AvpVehicle cars = 3;
inline int AvpCCTVMonitoringData::_internal_cars_size() const {
  return _internal_cars().size();
}
inline int AvpCCTVMonitoringData::cars_size() const {
  return _internal_cars_size();
}
inline void AvpCCTVMonitoringData::clear_cars() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cars_.Clear();
}
inline ::keti::AvpVehicle* AvpCCTVMonitoringData::mutable_cars(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:keti.AvpCCTVMonitoringData.cars)
  return _internal_mutable_cars()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>* AvpCCTVMonitoringData::mutable_cars()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpCCTVMonitoringData.cars)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cars();
}
inline const ::keti::AvpVehicle& AvpCCTVMonitoringData::cars(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCCTVMonitoringData.cars)
  return _internal_cars().Get(index);
}
inline ::keti::AvpVehicle* AvpCCTVMonitoringData::add_cars() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::keti::AvpVehicle* _add = _internal_mutable_cars()->Add();
  // @@protoc_insertion_point(field_add:keti.AvpCCTVMonitoringData.cars)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>& AvpCCTVMonitoringData::cars() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpCCTVMonitoringData.cars)
  return _internal_cars();
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>&
AvpCCTVMonitoringData::_internal_cars() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cars_;
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehicle>*
AvpCCTVMonitoringData::_internal_mutable_cars() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cars_;
}

// repeated .keti.AvpVehiclePos persons = 4;
inline int AvpCCTVMonitoringData::_internal_persons_size() const {
  return _internal_persons().size();
}
inline int AvpCCTVMonitoringData::persons_size() const {
  return _internal_persons_size();
}
inline void AvpCCTVMonitoringData::clear_persons() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.persons_.Clear();
}
inline ::keti::AvpVehiclePos* AvpCCTVMonitoringData::mutable_persons(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:keti.AvpCCTVMonitoringData.persons)
  return _internal_mutable_persons()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>* AvpCCTVMonitoringData::mutable_persons()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpCCTVMonitoringData.persons)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_persons();
}
inline const ::keti::AvpVehiclePos& AvpCCTVMonitoringData::persons(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCCTVMonitoringData.persons)
  return _internal_persons().Get(index);
}
inline ::keti::AvpVehiclePos* AvpCCTVMonitoringData::add_persons() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::keti::AvpVehiclePos* _add = _internal_mutable_persons()->Add();
  // @@protoc_insertion_point(field_add:keti.AvpCCTVMonitoringData.persons)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>& AvpCCTVMonitoringData::persons() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpCCTVMonitoringData.persons)
  return _internal_persons();
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>&
AvpCCTVMonitoringData::_internal_persons() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.persons_;
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpVehiclePos>*
AvpCCTVMonitoringData::_internal_mutable_persons() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.persons_;
}

// .keti.AvpParkingSpaces spaces = 5;
inline bool AvpCCTVMonitoringData::has_spaces() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spaces_ != nullptr);
  return value;
}
inline void AvpCCTVMonitoringData::clear_spaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spaces_ != nullptr) _impl_.spaces_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::AvpParkingSpaces& AvpCCTVMonitoringData::_internal_spaces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpParkingSpaces* p = _impl_.spaces_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpParkingSpaces&>(::keti::_AvpParkingSpaces_default_instance_);
}
inline const ::keti::AvpParkingSpaces& AvpCCTVMonitoringData::spaces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCCTVMonitoringData.spaces)
  return _internal_spaces();
}
inline void AvpCCTVMonitoringData::unsafe_arena_set_allocated_spaces(::keti::AvpParkingSpaces* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spaces_);
  }
  _impl_.spaces_ = reinterpret_cast<::keti::AvpParkingSpaces*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCCTVMonitoringData.spaces)
}
inline ::keti::AvpParkingSpaces* AvpCCTVMonitoringData::release_spaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpParkingSpaces* released = _impl_.spaces_;
  _impl_.spaces_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpParkingSpaces* AvpCCTVMonitoringData::unsafe_arena_release_spaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCCTVMonitoringData.spaces)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpParkingSpaces* temp = _impl_.spaces_;
  _impl_.spaces_ = nullptr;
  return temp;
}
inline ::keti::AvpParkingSpaces* AvpCCTVMonitoringData::_internal_mutable_spaces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.spaces_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpParkingSpaces>(GetArena());
    _impl_.spaces_ = reinterpret_cast<::keti::AvpParkingSpaces*>(p);
  }
  return _impl_.spaces_;
}
inline ::keti::AvpParkingSpaces* AvpCCTVMonitoringData::mutable_spaces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::AvpParkingSpaces* _msg = _internal_mutable_spaces();
  // @@protoc_insertion_point(field_mutable:keti.AvpCCTVMonitoringData.spaces)
  return _msg;
}
inline void AvpCCTVMonitoringData::set_allocated_spaces(::keti::AvpParkingSpaces* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.spaces_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.spaces_ = reinterpret_cast<::keti::AvpParkingSpaces*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCCTVMonitoringData.spaces)
}

// -------------------------------------------------------------------

// AvpVehicleParkingSensor

// uint32 FR_alarm = 1;
inline void AvpVehicleParkingSensor::clear_fr_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fr_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::fr_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FR_alarm)
  return _internal_fr_alarm();
}
inline void AvpVehicleParkingSensor::set_fr_alarm(::uint32_t value) {
  _internal_set_fr_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FR_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_fr_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fr_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_fr_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fr_alarm_ = value;
}

// uint32 FCS_alarm = 2;
inline void AvpVehicleParkingSensor::clear_fcs_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fcs_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::fcs_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FCS_alarm)
  return _internal_fcs_alarm();
}
inline void AvpVehicleParkingSensor::set_fcs_alarm(::uint32_t value) {
  _internal_set_fcs_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FCS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_fcs_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fcs_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_fcs_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fcs_alarm_ = value;
}

// uint32 FLS_alarm = 3;
inline void AvpVehicleParkingSensor::clear_fls_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fls_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::fls_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FLS_alarm)
  return _internal_fls_alarm();
}
inline void AvpVehicleParkingSensor::set_fls_alarm(::uint32_t value) {
  _internal_set_fls_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FLS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_fls_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fls_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_fls_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fls_alarm_ = value;
}

// uint32 FRS_alarm = 4;
inline void AvpVehicleParkingSensor::clear_frs_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frs_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::frs_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FRS_alarm)
  return _internal_frs_alarm();
}
inline void AvpVehicleParkingSensor::set_frs_alarm(::uint32_t value) {
  _internal_set_frs_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FRS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_frs_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frs_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_frs_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frs_alarm_ = value;
}

// uint32 FI_ind = 5;
inline void AvpVehicleParkingSensor::clear_fi_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fi_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::fi_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FI_ind)
  return _internal_fi_ind();
}
inline void AvpVehicleParkingSensor::set_fi_ind(::uint32_t value) {
  _internal_set_fi_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FI_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_fi_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fi_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_fi_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fi_ind_ = value;
}

// uint32 FOL_ind = 6;
inline void AvpVehicleParkingSensor::clear_fol_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fol_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::fol_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FOL_ind)
  return _internal_fol_ind();
}
inline void AvpVehicleParkingSensor::set_fol_ind(::uint32_t value) {
  _internal_set_fol_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FOL_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_fol_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fol_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_fol_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fol_ind_ = value;
}

// uint32 FOR_ind = 7;
inline void AvpVehicleParkingSensor::clear_for_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.for_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::for_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.FOR_ind)
  return _internal_for_ind();
}
inline void AvpVehicleParkingSensor::set_for_ind(::uint32_t value) {
  _internal_set_for_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.FOR_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_for_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.for_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_for_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.for_ind_ = value;
}

// uint32 RR_alarm = 8;
inline void AvpVehicleParkingSensor::clear_rr_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rr_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::rr_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.RR_alarm)
  return _internal_rr_alarm();
}
inline void AvpVehicleParkingSensor::set_rr_alarm(::uint32_t value) {
  _internal_set_rr_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.RR_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_rr_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rr_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_rr_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rr_alarm_ = value;
}

// uint32 RCS_alarm = 9;
inline void AvpVehicleParkingSensor::clear_rcs_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rcs_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::rcs_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.RCS_alarm)
  return _internal_rcs_alarm();
}
inline void AvpVehicleParkingSensor::set_rcs_alarm(::uint32_t value) {
  _internal_set_rcs_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.RCS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_rcs_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rcs_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_rcs_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rcs_alarm_ = value;
}

// uint32 RLS_alarm = 10;
inline void AvpVehicleParkingSensor::clear_rls_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rls_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::rls_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.RLS_alarm)
  return _internal_rls_alarm();
}
inline void AvpVehicleParkingSensor::set_rls_alarm(::uint32_t value) {
  _internal_set_rls_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.RLS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_rls_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rls_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_rls_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rls_alarm_ = value;
}

// uint32 RRS_alarm = 11;
inline void AvpVehicleParkingSensor::clear_rrs_alarm() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rrs_alarm_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::rrs_alarm() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.RRS_alarm)
  return _internal_rrs_alarm();
}
inline void AvpVehicleParkingSensor::set_rrs_alarm(::uint32_t value) {
  _internal_set_rrs_alarm(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.RRS_alarm)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_rrs_alarm() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rrs_alarm_;
}
inline void AvpVehicleParkingSensor::_internal_set_rrs_alarm(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rrs_alarm_ = value;
}

// uint32 RI_ind = 12;
inline void AvpVehicleParkingSensor::clear_ri_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ri_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::ri_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.RI_ind)
  return _internal_ri_ind();
}
inline void AvpVehicleParkingSensor::set_ri_ind(::uint32_t value) {
  _internal_set_ri_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.RI_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_ri_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ri_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_ri_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ri_ind_ = value;
}

// uint32 ROL_ind = 13;
inline void AvpVehicleParkingSensor::clear_rol_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rol_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::rol_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.ROL_ind)
  return _internal_rol_ind();
}
inline void AvpVehicleParkingSensor::set_rol_ind(::uint32_t value) {
  _internal_set_rol_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.ROL_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_rol_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.rol_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_rol_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.rol_ind_ = value;
}

// uint32 ROR_ind = 14;
inline void AvpVehicleParkingSensor::clear_ror_ind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ror_ind_ = 0u;
}
inline ::uint32_t AvpVehicleParkingSensor::ror_ind() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleParkingSensor.ROR_ind)
  return _internal_ror_ind();
}
inline void AvpVehicleParkingSensor::set_ror_ind(::uint32_t value) {
  _internal_set_ror_ind(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleParkingSensor.ROR_ind)
}
inline ::uint32_t AvpVehicleParkingSensor::_internal_ror_ind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ror_ind_;
}
inline void AvpVehicleParkingSensor::_internal_set_ror_ind(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ror_ind_ = value;
}

// -------------------------------------------------------------------

// AvpVehicleSteeringSensor

// double sas_angle = 1;
inline void AvpVehicleSteeringSensor::clear_sas_angle() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sas_angle_ = 0;
}
inline double AvpVehicleSteeringSensor::sas_angle() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleSteeringSensor.sas_angle)
  return _internal_sas_angle();
}
inline void AvpVehicleSteeringSensor::set_sas_angle(double value) {
  _internal_set_sas_angle(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleSteeringSensor.sas_angle)
}
inline double AvpVehicleSteeringSensor::_internal_sas_angle() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sas_angle_;
}
inline void AvpVehicleSteeringSensor::_internal_set_sas_angle(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sas_angle_ = value;
}

// double sas_speed = 2;
inline void AvpVehicleSteeringSensor::clear_sas_speed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sas_speed_ = 0;
}
inline double AvpVehicleSteeringSensor::sas_speed() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleSteeringSensor.sas_speed)
  return _internal_sas_speed();
}
inline void AvpVehicleSteeringSensor::set_sas_speed(double value) {
  _internal_set_sas_speed(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleSteeringSensor.sas_speed)
}
inline double AvpVehicleSteeringSensor::_internal_sas_speed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sas_speed_;
}
inline void AvpVehicleSteeringSensor::_internal_set_sas_speed(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sas_speed_ = value;
}

// -------------------------------------------------------------------

// AvpVehicleStabilitySensor

// double esp_lat_accel = 1;
inline void AvpVehicleStabilitySensor::clear_esp_lat_accel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_lat_accel_ = 0;
}
inline double AvpVehicleStabilitySensor::esp_lat_accel() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleStabilitySensor.esp_lat_accel)
  return _internal_esp_lat_accel();
}
inline void AvpVehicleStabilitySensor::set_esp_lat_accel(double value) {
  _internal_set_esp_lat_accel(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleStabilitySensor.esp_lat_accel)
}
inline double AvpVehicleStabilitySensor::_internal_esp_lat_accel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.esp_lat_accel_;
}
inline void AvpVehicleStabilitySensor::_internal_set_esp_lat_accel(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_lat_accel_ = value;
}

// double esp_long_accel = 2;
inline void AvpVehicleStabilitySensor::clear_esp_long_accel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_long_accel_ = 0;
}
inline double AvpVehicleStabilitySensor::esp_long_accel() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleStabilitySensor.esp_long_accel)
  return _internal_esp_long_accel();
}
inline void AvpVehicleStabilitySensor::set_esp_long_accel(double value) {
  _internal_set_esp_long_accel(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleStabilitySensor.esp_long_accel)
}
inline double AvpVehicleStabilitySensor::_internal_esp_long_accel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.esp_long_accel_;
}
inline void AvpVehicleStabilitySensor::_internal_set_esp_long_accel(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_long_accel_ = value;
}

// double esp_yaw_rate = 3;
inline void AvpVehicleStabilitySensor::clear_esp_yaw_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_yaw_rate_ = 0;
}
inline double AvpVehicleStabilitySensor::esp_yaw_rate() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleStabilitySensor.esp_yaw_rate)
  return _internal_esp_yaw_rate();
}
inline void AvpVehicleStabilitySensor::set_esp_yaw_rate(double value) {
  _internal_set_esp_yaw_rate(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleStabilitySensor.esp_yaw_rate)
}
inline double AvpVehicleStabilitySensor::_internal_esp_yaw_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.esp_yaw_rate_;
}
inline void AvpVehicleStabilitySensor::_internal_set_esp_yaw_rate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.esp_yaw_rate_ = value;
}

// -------------------------------------------------------------------

// AvpVehicleDoorSensor

// int32 front = 1;
inline void AvpVehicleDoorSensor::clear_front() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.front_ = 0;
}
inline ::int32_t AvpVehicleDoorSensor::front() const {
  // @@protoc_insertion_point(field_get:keti.AvpVehicleDoorSensor.front)
  return _internal_front();
}
inline void AvpVehicleDoorSensor::set_front(::int32_t value) {
  _internal_set_front(value);
  // @@protoc_insertion_point(field_set:keti.AvpVehicleDoorSensor.front)
}
inline ::int32_t AvpVehicleDoorSensor::_internal_front() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.front_;
}
inline void AvpVehicleDoorSensor::_internal_set_front(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.front_ = value;
}

// -------------------------------------------------------------------

// AvpCANSensorData

// .google.protobuf.Timestamp time = 1;
inline bool AvpCANSensorData::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.time_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& AvpCANSensorData::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.time_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& AvpCANSensorData::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCANSensorData.time)
  return _internal_time();
}
inline void AvpCANSensorData::unsafe_arena_set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }
  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCANSensorData.time)
}
inline ::google::protobuf::Timestamp* AvpCANSensorData::release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.time_;
  _impl_.time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* AvpCANSensorData::unsafe_arena_release_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCANSensorData.time)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.time_;
  _impl_.time_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* AvpCANSensorData::_internal_mutable_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.time_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.time_;
}
inline ::google::protobuf::Timestamp* AvpCANSensorData::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:keti.AvpCANSensorData.time)
  return _msg;
}
inline void AvpCANSensorData::set_allocated_time(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.time_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.time_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCANSensorData.time)
}

// .keti.AvpVehicleParkingSensor parking = 2;
inline bool AvpCANSensorData::has_parking() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.parking_ != nullptr);
  return value;
}
inline void AvpCANSensorData::clear_parking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parking_ != nullptr) _impl_.parking_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::AvpVehicleParkingSensor& AvpCANSensorData::_internal_parking() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpVehicleParkingSensor* p = _impl_.parking_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpVehicleParkingSensor&>(::keti::_AvpVehicleParkingSensor_default_instance_);
}
inline const ::keti::AvpVehicleParkingSensor& AvpCANSensorData::parking() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCANSensorData.parking)
  return _internal_parking();
}
inline void AvpCANSensorData::unsafe_arena_set_allocated_parking(::keti::AvpVehicleParkingSensor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.parking_);
  }
  _impl_.parking_ = reinterpret_cast<::keti::AvpVehicleParkingSensor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCANSensorData.parking)
}
inline ::keti::AvpVehicleParkingSensor* AvpCANSensorData::release_parking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpVehicleParkingSensor* released = _impl_.parking_;
  _impl_.parking_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpVehicleParkingSensor* AvpCANSensorData::unsafe_arena_release_parking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCANSensorData.parking)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::AvpVehicleParkingSensor* temp = _impl_.parking_;
  _impl_.parking_ = nullptr;
  return temp;
}
inline ::keti::AvpVehicleParkingSensor* AvpCANSensorData::_internal_mutable_parking() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.parking_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpVehicleParkingSensor>(GetArena());
    _impl_.parking_ = reinterpret_cast<::keti::AvpVehicleParkingSensor*>(p);
  }
  return _impl_.parking_;
}
inline ::keti::AvpVehicleParkingSensor* AvpCANSensorData::mutable_parking() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::AvpVehicleParkingSensor* _msg = _internal_mutable_parking();
  // @@protoc_insertion_point(field_mutable:keti.AvpCANSensorData.parking)
  return _msg;
}
inline void AvpCANSensorData::set_allocated_parking(::keti::AvpVehicleParkingSensor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.parking_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.parking_ = reinterpret_cast<::keti::AvpVehicleParkingSensor*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCANSensorData.parking)
}

// .keti.AvpVehicleSteeringSensor steering = 3;
inline bool AvpCANSensorData::has_steering() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.steering_ != nullptr);
  return value;
}
inline void AvpCANSensorData::clear_steering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.steering_ != nullptr) _impl_.steering_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::keti::AvpVehicleSteeringSensor& AvpCANSensorData::_internal_steering() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpVehicleSteeringSensor* p = _impl_.steering_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpVehicleSteeringSensor&>(::keti::_AvpVehicleSteeringSensor_default_instance_);
}
inline const ::keti::AvpVehicleSteeringSensor& AvpCANSensorData::steering() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCANSensorData.steering)
  return _internal_steering();
}
inline void AvpCANSensorData::unsafe_arena_set_allocated_steering(::keti::AvpVehicleSteeringSensor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.steering_);
  }
  _impl_.steering_ = reinterpret_cast<::keti::AvpVehicleSteeringSensor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCANSensorData.steering)
}
inline ::keti::AvpVehicleSteeringSensor* AvpCANSensorData::release_steering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::keti::AvpVehicleSteeringSensor* released = _impl_.steering_;
  _impl_.steering_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpVehicleSteeringSensor* AvpCANSensorData::unsafe_arena_release_steering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCANSensorData.steering)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::keti::AvpVehicleSteeringSensor* temp = _impl_.steering_;
  _impl_.steering_ = nullptr;
  return temp;
}
inline ::keti::AvpVehicleSteeringSensor* AvpCANSensorData::_internal_mutable_steering() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.steering_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpVehicleSteeringSensor>(GetArena());
    _impl_.steering_ = reinterpret_cast<::keti::AvpVehicleSteeringSensor*>(p);
  }
  return _impl_.steering_;
}
inline ::keti::AvpVehicleSteeringSensor* AvpCANSensorData::mutable_steering() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::keti::AvpVehicleSteeringSensor* _msg = _internal_mutable_steering();
  // @@protoc_insertion_point(field_mutable:keti.AvpCANSensorData.steering)
  return _msg;
}
inline void AvpCANSensorData::set_allocated_steering(::keti::AvpVehicleSteeringSensor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.steering_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.steering_ = reinterpret_cast<::keti::AvpVehicleSteeringSensor*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCANSensorData.steering)
}

// .keti.AvpVehicleStabilitySensor stability = 4;
inline bool AvpCANSensorData::has_stability() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stability_ != nullptr);
  return value;
}
inline void AvpCANSensorData::clear_stability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stability_ != nullptr) _impl_.stability_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::keti::AvpVehicleStabilitySensor& AvpCANSensorData::_internal_stability() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpVehicleStabilitySensor* p = _impl_.stability_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpVehicleStabilitySensor&>(::keti::_AvpVehicleStabilitySensor_default_instance_);
}
inline const ::keti::AvpVehicleStabilitySensor& AvpCANSensorData::stability() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCANSensorData.stability)
  return _internal_stability();
}
inline void AvpCANSensorData::unsafe_arena_set_allocated_stability(::keti::AvpVehicleStabilitySensor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.stability_);
  }
  _impl_.stability_ = reinterpret_cast<::keti::AvpVehicleStabilitySensor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCANSensorData.stability)
}
inline ::keti::AvpVehicleStabilitySensor* AvpCANSensorData::release_stability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::keti::AvpVehicleStabilitySensor* released = _impl_.stability_;
  _impl_.stability_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpVehicleStabilitySensor* AvpCANSensorData::unsafe_arena_release_stability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCANSensorData.stability)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::keti::AvpVehicleStabilitySensor* temp = _impl_.stability_;
  _impl_.stability_ = nullptr;
  return temp;
}
inline ::keti::AvpVehicleStabilitySensor* AvpCANSensorData::_internal_mutable_stability() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.stability_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpVehicleStabilitySensor>(GetArena());
    _impl_.stability_ = reinterpret_cast<::keti::AvpVehicleStabilitySensor*>(p);
  }
  return _impl_.stability_;
}
inline ::keti::AvpVehicleStabilitySensor* AvpCANSensorData::mutable_stability() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::keti::AvpVehicleStabilitySensor* _msg = _internal_mutable_stability();
  // @@protoc_insertion_point(field_mutable:keti.AvpCANSensorData.stability)
  return _msg;
}
inline void AvpCANSensorData::set_allocated_stability(::keti::AvpVehicleStabilitySensor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.stability_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.stability_ = reinterpret_cast<::keti::AvpVehicleStabilitySensor*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCANSensorData.stability)
}

// .keti.AvpVehicleDoorSensor door = 5;
inline bool AvpCANSensorData::has_door() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.door_ != nullptr);
  return value;
}
inline void AvpCANSensorData::clear_door() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.door_ != nullptr) _impl_.door_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::keti::AvpVehicleDoorSensor& AvpCANSensorData::_internal_door() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::AvpVehicleDoorSensor* p = _impl_.door_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::AvpVehicleDoorSensor&>(::keti::_AvpVehicleDoorSensor_default_instance_);
}
inline const ::keti::AvpVehicleDoorSensor& AvpCANSensorData::door() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpCANSensorData.door)
  return _internal_door();
}
inline void AvpCANSensorData::unsafe_arena_set_allocated_door(::keti::AvpVehicleDoorSensor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.door_);
  }
  _impl_.door_ = reinterpret_cast<::keti::AvpVehicleDoorSensor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpCANSensorData.door)
}
inline ::keti::AvpVehicleDoorSensor* AvpCANSensorData::release_door() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::keti::AvpVehicleDoorSensor* released = _impl_.door_;
  _impl_.door_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::AvpVehicleDoorSensor* AvpCANSensorData::unsafe_arena_release_door() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpCANSensorData.door)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::keti::AvpVehicleDoorSensor* temp = _impl_.door_;
  _impl_.door_ = nullptr;
  return temp;
}
inline ::keti::AvpVehicleDoorSensor* AvpCANSensorData::_internal_mutable_door() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.door_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::AvpVehicleDoorSensor>(GetArena());
    _impl_.door_ = reinterpret_cast<::keti::AvpVehicleDoorSensor*>(p);
  }
  return _impl_.door_;
}
inline ::keti::AvpVehicleDoorSensor* AvpCANSensorData::mutable_door() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::keti::AvpVehicleDoorSensor* _msg = _internal_mutable_door();
  // @@protoc_insertion_point(field_mutable:keti.AvpCANSensorData.door)
  return _msg;
}
inline void AvpCANSensorData::set_allocated_door(::keti::AvpVehicleDoorSensor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.door_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.door_ = reinterpret_cast<::keti::AvpVehicleDoorSensor*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpCANSensorData.door)
}

// -------------------------------------------------------------------

// AvpControlMessage

// .keti.AvpControlMessage.Type type = 1;
inline void AvpControlMessage::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::keti::AvpControlMessage_Type AvpControlMessage::type() const {
  // @@protoc_insertion_point(field_get:keti.AvpControlMessage.type)
  return _internal_type();
}
inline void AvpControlMessage::set_type(::keti::AvpControlMessage_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:keti.AvpControlMessage.type)
}
inline ::keti::AvpControlMessage_Type AvpControlMessage::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::keti::AvpControlMessage_Type>(_impl_.type_);
}
inline void AvpControlMessage::_internal_set_type(::keti::AvpControlMessage_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// .keti.AvpControlMessage.Code code = 2;
inline void AvpControlMessage::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = 0;
}
inline ::keti::AvpControlMessage_Code AvpControlMessage::code() const {
  // @@protoc_insertion_point(field_get:keti.AvpControlMessage.code)
  return _internal_code();
}
inline void AvpControlMessage::set_code(::keti::AvpControlMessage_Code value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:keti.AvpControlMessage.code)
}
inline ::keti::AvpControlMessage_Code AvpControlMessage::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::keti::AvpControlMessage_Code>(_impl_.code_);
}
inline void AvpControlMessage::_internal_set_code(::keti::AvpControlMessage_Code value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_ = value;
}

// -------------------------------------------------------------------

// AvpDataMessage

// repeated .keti.AvpCANSensorData data = 1;
inline int AvpDataMessage::_internal_data_size() const {
  return _internal_data().size();
}
inline int AvpDataMessage::data_size() const {
  return _internal_data_size();
}
inline void AvpDataMessage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline ::keti::AvpCANSensorData* AvpDataMessage::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:keti.AvpDataMessage.data)
  return _internal_mutable_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>* AvpDataMessage::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:keti.AvpDataMessage.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::keti::AvpCANSensorData& AvpDataMessage::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpDataMessage.data)
  return _internal_data().Get(index);
}
inline ::keti::AvpCANSensorData* AvpDataMessage::add_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::keti::AvpCANSensorData* _add = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add:keti.AvpDataMessage.data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>& AvpDataMessage::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:keti.AvpDataMessage.data)
  return _internal_data();
}
inline const ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>&
AvpDataMessage::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<::keti::AvpCANSensorData>*
AvpDataMessage::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// AvpMessage

// .keti.Envelope envelope = 1;
inline bool AvpMessage::has_envelope() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.envelope_ != nullptr);
  return value;
}
inline void AvpMessage::clear_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ != nullptr) _impl_.envelope_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::keti::Envelope& AvpMessage::_internal_envelope() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Envelope* p = _impl_.envelope_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Envelope&>(::keti::_Envelope_default_instance_);
}
inline const ::keti::Envelope& AvpMessage::envelope() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpMessage.envelope)
  return _internal_envelope();
}
inline void AvpMessage::unsafe_arena_set_allocated_envelope(::keti::Envelope* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.envelope_);
  }
  _impl_.envelope_ = reinterpret_cast<::keti::Envelope*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpMessage.envelope)
}
inline ::keti::Envelope* AvpMessage::release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Envelope* released = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Envelope* AvpMessage::unsafe_arena_release_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpMessage.envelope)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::keti::Envelope* temp = _impl_.envelope_;
  _impl_.envelope_ = nullptr;
  return temp;
}
inline ::keti::Envelope* AvpMessage::_internal_mutable_envelope() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.envelope_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Envelope>(GetArena());
    _impl_.envelope_ = reinterpret_cast<::keti::Envelope*>(p);
  }
  return _impl_.envelope_;
}
inline ::keti::Envelope* AvpMessage::mutable_envelope() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::keti::Envelope* _msg = _internal_mutable_envelope();
  // @@protoc_insertion_point(field_mutable:keti.AvpMessage.envelope)
  return _msg;
}
inline void AvpMessage::set_allocated_envelope(::keti::Envelope* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.envelope_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.envelope_ = reinterpret_cast<::keti::Envelope*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpMessage.envelope)
}

// .keti.Ids id = 2;
inline bool AvpMessage::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.id_ != nullptr);
  return value;
}
inline void AvpMessage::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ != nullptr) _impl_.id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::keti::Ids& AvpMessage::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::keti::Ids* p = _impl_.id_;
  return p != nullptr ? *p : reinterpret_cast<const ::keti::Ids&>(::keti::_Ids_default_instance_);
}
inline const ::keti::Ids& AvpMessage::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpMessage.id)
  return _internal_id();
}
inline void AvpMessage::unsafe_arena_set_allocated_id(::keti::Ids* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.id_);
  }
  _impl_.id_ = reinterpret_cast<::keti::Ids*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpMessage.id)
}
inline ::keti::Ids* AvpMessage::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Ids* released = _impl_.id_;
  _impl_.id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::keti::Ids* AvpMessage::unsafe_arena_release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:keti.AvpMessage.id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::keti::Ids* temp = _impl_.id_;
  _impl_.id_ = nullptr;
  return temp;
}
inline ::keti::Ids* AvpMessage::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.id_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::keti::Ids>(GetArena());
    _impl_.id_ = reinterpret_cast<::keti::Ids*>(p);
  }
  return _impl_.id_;
}
inline ::keti::Ids* AvpMessage::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::keti::Ids* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:keti.AvpMessage.id)
  return _msg;
}
inline void AvpMessage::set_allocated_id(::keti::Ids* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.id_ = reinterpret_cast<::keti::Ids*>(value);
  // @@protoc_insertion_point(field_set_allocated:keti.AvpMessage.id)
}

// .keti.AvpControlMessage ctrl = 3;
inline bool AvpMessage::has_ctrl() const {
  return message_case() == kCtrl;
}
inline bool AvpMessage::_internal_has_ctrl() const {
  return message_case() == kCtrl;
}
inline void AvpMessage::set_has_ctrl() {
  _impl_._oneof_case_[0] = kCtrl;
}
inline void AvpMessage::clear_ctrl() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kCtrl) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.ctrl_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.ctrl_);
    }
    clear_has_message();
  }
}
inline ::keti::AvpControlMessage* AvpMessage::release_ctrl() {
  // @@protoc_insertion_point(field_release:keti.AvpMessage.ctrl)
  if (message_case() == kCtrl) {
    clear_has_message();
    auto* temp = _impl_.message_.ctrl_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.ctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::keti::AvpControlMessage& AvpMessage::_internal_ctrl() const {
  return message_case() == kCtrl ? *_impl_.message_.ctrl_ : reinterpret_cast<::keti::AvpControlMessage&>(::keti::_AvpControlMessage_default_instance_);
}
inline const ::keti::AvpControlMessage& AvpMessage::ctrl() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpMessage.ctrl)
  return _internal_ctrl();
}
inline ::keti::AvpControlMessage* AvpMessage::unsafe_arena_release_ctrl() {
  // @@protoc_insertion_point(field_unsafe_arena_release:keti.AvpMessage.ctrl)
  if (message_case() == kCtrl) {
    clear_has_message();
    auto* temp = _impl_.message_.ctrl_;
    _impl_.message_.ctrl_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AvpMessage::unsafe_arena_set_allocated_ctrl(::keti::AvpControlMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_ctrl();
    _impl_.message_.ctrl_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpMessage.ctrl)
}
inline ::keti::AvpControlMessage* AvpMessage::_internal_mutable_ctrl() {
  if (message_case() != kCtrl) {
    clear_message();
    set_has_ctrl();
    _impl_.message_.ctrl_ =
        ::google::protobuf::Message::DefaultConstruct<::keti::AvpControlMessage>(GetArena());
  }
  return _impl_.message_.ctrl_;
}
inline ::keti::AvpControlMessage* AvpMessage::mutable_ctrl() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::keti::AvpControlMessage* _msg = _internal_mutable_ctrl();
  // @@protoc_insertion_point(field_mutable:keti.AvpMessage.ctrl)
  return _msg;
}

// .keti.AvpDataMessage data = 4;
inline bool AvpMessage::has_data() const {
  return message_case() == kData;
}
inline bool AvpMessage::_internal_has_data() const {
  return message_case() == kData;
}
inline void AvpMessage::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void AvpMessage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_case() == kData) {
    if (GetArena() == nullptr) {
      delete _impl_.message_.data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.message_.data_);
    }
    clear_has_message();
  }
}
inline ::keti::AvpDataMessage* AvpMessage::release_data() {
  // @@protoc_insertion_point(field_release:keti.AvpMessage.data)
  if (message_case() == kData) {
    clear_has_message();
    auto* temp = _impl_.message_.data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.message_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::keti::AvpDataMessage& AvpMessage::_internal_data() const {
  return message_case() == kData ? *_impl_.message_.data_ : reinterpret_cast<::keti::AvpDataMessage&>(::keti::_AvpDataMessage_default_instance_);
}
inline const ::keti::AvpDataMessage& AvpMessage::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:keti.AvpMessage.data)
  return _internal_data();
}
inline ::keti::AvpDataMessage* AvpMessage::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:keti.AvpMessage.data)
  if (message_case() == kData) {
    clear_has_message();
    auto* temp = _impl_.message_.data_;
    _impl_.message_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AvpMessage::unsafe_arena_set_allocated_data(::keti::AvpDataMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_message();
  if (value) {
    set_has_data();
    _impl_.message_.data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keti.AvpMessage.data)
}
inline ::keti::AvpDataMessage* AvpMessage::_internal_mutable_data() {
  if (message_case() != kData) {
    clear_message();
    set_has_data();
    _impl_.message_.data_ =
        ::google::protobuf::Message::DefaultConstruct<::keti::AvpDataMessage>(GetArena());
  }
  return _impl_.message_.data_;
}
inline ::keti::AvpDataMessage* AvpMessage::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::keti::AvpDataMessage* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:keti.AvpMessage.data)
  return _msg;
}

inline bool AvpMessage::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void AvpMessage::clear_has_message() {
  _impl_._oneof_case_[0] = MESSAGE_NOT_SET;
}
inline AvpMessage::MessageCase AvpMessage::message_case() const {
  return AvpMessage::MessageCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace keti


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::keti::AvpVehicleAbnormalData_AbnormalType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::keti::AvpVehicleAbnormalData_AbnormalType>() {
  return ::keti::AvpVehicleAbnormalData_AbnormalType_descriptor();
}
template <>
struct is_proto_enum<::keti::AvpControlMessage_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::keti::AvpControlMessage_Type>() {
  return ::keti::AvpControlMessage_Type_descriptor();
}
template <>
struct is_proto_enum<::keti::AvpControlMessage_Code> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::keti::AvpControlMessage_Code>() {
  return ::keti::AvpControlMessage_Code_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_Avp_2eproto_2epb_2eh
